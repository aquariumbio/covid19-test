{"config":{"title":"diagnostic_rt_qpcr","description":"No description given","copyright":"No copyright declared","version":"no version info","authors":[],"maintainer":{"name":"No maintainer","email":"noone@nowehere"},"acknowledgements":[],"github":{"repo":"none","user":"none","access_token":"none"},"keywords":[],"aquadoc_version":"1.0.2"},"components":[{"sample_types":[{"id":10,"name":"Master Mix","description":"Master Mix sample type TODO Make better description","created_at":"2020-06-29T10:15:28.000-07:00","updated_at":"2020-06-29T10:15:28.000-07:00","field_types":[]}],"object_types":[{"id":18,"name":"96-well qPCR Plate","description":"96-well qPCR Reaction","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-29T10:26:41.000-07:00","unit":"qPCR Reaction","cost":0.01,"release_method":"return","release_description":"","sample_type_id":3,"image":"","prefix":"","rows":8,"columns":12,"sample_type_name":"qPCR Reaction"}],"operation_type":{"name":"Add No Template Control","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"PCR Plate","sample_types":["Master Mix"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":19,"preferred_field_type_id":53,"choices":null},{"ftype":"sample","role":"output","name":"PCR Plate","sample_types":["Master Mix"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Standard Libs/PlanParams'\nneeds 'Standard Libs/CommonInputOutputNames'\nneeds 'Standard Libs/Debug'\nneeds 'Standard Libs/Pipettors'\nneeds 'Standard Libs/LabwareNames'\nneeds 'Collection Management/CollectionActions'\nneeds 'Collection Management/CollectionDisplay'\nneeds 'Microtiter Plates/PlateLayoutGenerator'\nneeds 'PCR Libs/PCRComposition'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\n\n# Protocol for setting up a master mix plate for RT-qPCR\n# @note Instructions adapted from the CDC COVID-19 detection protocol\n#   https://www.fda.gov/media/134922/download\n#\n# 12) Prior to moving to the nucleic acid handling area, prepare the\n#   No Template Control (NTC) reactions for column #1 in the\n#   assay preparation area.\n#\n# 13) Pipette 5 uL of nuclease-free water into the NTC sample wells\n#   (Figure 2, column 1). Securely cap NTC wells before proceeding.\n#\n# 14) Cover the entire reaction plate and move the reaction plate to\n#   the specimen nucleic acid handling area.\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass Protocol\n  # Standard Libs\n  include PlanParams\n  include CommonInputOutputNames\n  include Debug\n  include Pipettors\n  include LabwareNames\n\n  # Collection Management\n  include CollectionActions\n  include CollectionDisplay\n\n  # Diagnostic RT-qPCR\n  include DataAssociationKeys\n\n  WATER = 'Molecular Grade Water'\n  RNA_FREE_WORKSPACE = 'reagent set-up room'\n  PLATE = 'PCR Plate'\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {}\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {\n      program_name: 'CDC_TaqPath_CG',\n      sample_group_size: 3\n    }\n  end\n\n  ########## MAIN ##########\n\n  def main\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n    return {} if operations.errored.any?\n\n    update_operation_params(\n      operations: operations,\n      default_operation_params: default_operation_params\n    )\n\n    operations.retrieve.make\n\n    add_no_template_controls(operations: operations)\n\n    operations.store\n\n    {}\n  end\n\n  # Group_Size and Program name are attributes of the plate\n  # and should be associated to the plate from Prepare Master Mix\n  def add_no_template_controls(operations:)\n    operations.each do |op|\n      group_size = op.input(PLATE).collection.get(GROUP_SIZE_KEY)\n      program_name = op.input(PLATE).collection.get(COMPOSITION_NAME_KEY)\n\n      if debug\n        group_size = 3\n        program_name = 'CDC_TaqPath_CG'\n      end\n\n      layout_generator = PlateLayoutGeneratorFactory.build(\n        group_size: group_size # op.temporary[:options][:sample_group_size]\n      )\n      layout_group = layout_generator.next_group\n      composition = PCRCompositionFactory.build(\n        program_name: program_name # op.temporary[:options][:program_name]\n      )\n      volume = composition.water.qty_display\n      collection = op.output(PLATE).collection\n\n      show do\n        title \"Pipet No Template Control (NTC) samples into plate #{collection}\"\n\n        note \"Pipet #{volume} of #{WATER} into the indicated wells of\" \\\n          \" plate #{collection}\"\n        table highlight_collection_rc(collection, layout_group, check: true)\n      end\n    end\n  end\n\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# frozen_string_literal: true\n\nclass ProtocolTest \u003c ProtocolTestBase\n  def setup\n    ops = add_random_operations(1)\n  end\n\n  def analyze\n    log('Hello from Nemo')\n    assert_equal(@backtrace.last[:operation], 'complete')\n  end\nend","timing":null}},{"sample_types":[{"id":1,"name":"RNA","description":"A sample of RNA","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","field_types":[]}],"object_types":[{"id":19,"name":"Lyophilized RNA","description":"Lyophilized RNA","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-26T09:02:42.000-07:00","unit":"RNA","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":null,"prefix":"","rows":null,"columns":null,"sample_type_name":"RNA"},{"id":4,"name":"Purified RNA in 1.5 mL tube","description":"Purified RNA in 1.5 mL tube","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","unit":"RNA","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":null,"prefix":"M80","rows":null,"columns":null,"sample_type_name":"RNA"}],"operation_type":{"name":"Aliquot Positive Template","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Template","sample_types":["RNA"],"object_types":["Lyophilized RNA"],"part":false,"array":false,"routing":"T","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Template","sample_types":["RNA"],"object_types":["Purified RNA in 1.5 mL tube"],"part":false,"array":false,"routing":"T","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# frozen_string_literal: true\n\nneeds 'Diagnostic RT-qPCR/PrepareRTqPCRValidation'\nneeds 'Diagnostic RT-qPCR/PrepareqPCRPlateHelper'\n\n# Protocol for setting up a plate with extracted RNA samples\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n# @author Cannon Mallory \u003cmalloc3@uw.edu\u003e\nclass Protocol\n  include PrepareqPCRPlateHelper\n  include PrepareRTqPCRValidation\n\n  def default_job_params\n    {\n      primer_set: 'RP_N2',\n      max_inputs: 24,\n      group_size: 3,\n      method: 'sample_layout'.to_sym, \n      additional_inputs: [\n        # {\n        #   name: nil,\n        #   container: nil,\n        #   station: 'bench'\n        #   volume{\n        #       qty: nil,\n        #       units: MIROLITERS\n        # }\n      ],\n      negative_controls: {\n        name: 'NTC',\n        first_well: [0, 0],\n        station: 'negative_control station',\n        volume: {\n          qty: 5,\n          units: MICROLITERS\n        },\n        additional_inputs: [\n          # {\n          #   name: nil,\n          #   container: nil,\n          #   station: nil,\n          #   volume{\n          #        qty: nil,\n          #        units: MIROLITERS\n          #   }\n          # }\n        ]\n      },\n      positive_controls:{\n        name: 'nCoVPC',\n        first_well: [0, 11],\n        station: 'positive control station',\n        volume: {\n          qty: 5,\n          units: MICROLITERS\n        },\n        additional_inputs: [\n          # {\n          #   name: nil,\n          #   container: nil,\n          #   station: nil,\n          #   volume{\n          #        qty: nil,\n          #        units: MIROLITERS\n          #   }\n          # }\n        ]\n      },\n      standard_samples: {\n        station: 'sample handling station',\n        volume: {\n          qty: 5,\n          units: MICROLITERS\n        },\n        additional_inputs: [\n          # {\n          #   name: nil,\n          #   container: nil,\n          #   station: nil,\n          #   volume{\n          #        qty: nil,\n          #        units: MIROLITERS\n          #   }\n          # }\n        ]\n      }\n    }\n  end\n\n  def default_operation_params\n    {}\n  end\n\n  def main\n    operations.reject!{ |op| validate(operations: operations).include?(op) }\n    return {} if operations.empty?\n\n    operations.retrieve\n\n    operations.each do |op|\n      run_job(default_job_params: default_job_params,\n              default_operation_params: default_operation_params,\n              op: op)\n    end\n\n    operations.store\n\n    {}\n\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"","timing":null}},{"sample_types":[{"id":9,"name":"Primer/Probe Mix","description":"Primer/Probe Mix for qPCR","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-26T09:02:42.000-07:00","field_types":[]}],"object_types":[{"id":20,"name":"Lyophilized Primer Mix","description":"Lyophilized Primer Mix","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-26T09:02:42.000-07:00","unit":"Primer Mix","cost":0.01,"release_method":"return","release_description":"","sample_type_id":9,"image":null,"prefix":"","rows":null,"columns":null,"sample_type_name":"Primer/Probe Mix"},{"id":21,"name":"Primer Mix Aliquot","description":"Primer Mix Aliquot","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-26T09:02:42.000-07:00","unit":"Primer Mix","cost":0.01,"release_method":"return","release_description":"","sample_type_id":9,"image":null,"prefix":"M20","rows":null,"columns":null,"sample_type_name":"Primer/Probe Mix"}],"operation_type":{"name":"Aliquot Primer/Probe","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Primer/Probe Mix","sample_types":["Primer/Probe Mix"],"object_types":["Lyophilized Primer Mix"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Primer/Probe Mix","sample_types":["Primer/Probe Mix"],"object_types":["Primer Mix Aliquot"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# Aliquot Primer Probe\n# Written By Dany Fu 2020-05-05\n\nneeds 'Diagnostic RT-qPCR/DiagnosticRTqPCRHelper'\n\n# 1) Upon receipt, store dried primers and probes at 2-8C.\n# 2) Precautions: These reagents should only be handled in a clean area and\n# stored at appropriate temperatures (see below) in the dark. Freeze-thaw cycles\n# should be avoided. Maintain cold when thawed.\n# 3) Using aseptic technique, suspend dried reagents in 1.5 mL of nuclease-free\n# water (50X working concentration) and allow to rehydrate for 15 min at room\n# temperature in the dark.\n# 4) Mix gently and aliquot primers/probe in 300 uL volumes into 5 pre-labeled\n# tubes. Store a single aliquot of primers/probe at 2-8oC in the dark. Do not\n# refreeze (stable for up to 4 months). Store remaining aliquots at \u003c= -20oC\n# in a non-frost-free freezer.\nclass Protocol\n  include DiagnosticRTqPCRHelper\n\n  OUTPUT_ITEMS_NUM = { qty: 5, units: TUBE_MICROFUGE }.freeze\n  TIME_REHYDRATE = { qty: 15, units: MINUTES }.freeze\n  VOL_WATER = { qty: 1.5, units: MILLILITERS }.freeze\n  VOL_SUSPENSION = { qty: 300, units: MICROLITERS }.freeze\n\n  COLD_ROOM = 'M4'.freeze\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {}\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {}\n  end\n\n  ########## MAIN ##########\n\n  def main\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n    return {} if operations.errored.any?\n\n    update_operation_params(\n      operations: operations,\n      default_operation_params: default_operation_params\n    )\n\n    get_tubes(count: operations.length)\n    operations.retrieve\n\n    save_output(operations)\n    suspend_primer_mix\n\n    # Group the operations by the input reagent\n    ops_by_input = operations.group_by { |op| op.input(PRIMER_MIX).item }\n    ops_by_input.each do |primer, ops|\n      make_aliquots(ops: ops, primer: primer)\n    end\n\n    operations.store(interactive: true, io: 'output', method: 'boxes')\n  end\n\n  # Get 5 1.5 mL tubes per dried reagent\n  # @param count [Integer] the number of operations currently running\n  def get_tubes(count:)\n    show do\n      title \"Get new #{TUBE_MICROFUGE}\"\n      check \"Please get #{count * OUTPUT_ITEMS_NUM[:qty]} #{TUBE_MICROFUGE}\"\n    end\n  end\n\n  # Create and save multiple output Items per operation\n  # @param operations [OperationList] List of operations\n  def save_output(operations)\n    operations.make\n\n    operations.each do |op|\n      op.output(PRIMER_MIX).item.associate :volume, VOL_SUSPENSION[:qty]\n\n      output_primer = op.output(PRIMER_MIX).sample\n      # makes 4 additional aliquots per op\n      (OUTPUT_ITEMS_NUM[:qty] - 1).times do\n        new_aliquot = output_primer.make_item('Primer Mix Aliquot')\n        new_aliquot.associate :volume, VOL_SUSPENSION[:qty]\n        link_output_item(operation: op, sample: output_primer, item: new_aliquot)\n      end\n    end\n  end\n\n  # Manually link the item to the operation as an output\n  # @param op [Operation] the operation that creates the items\n  # @param sample [Sample] the sample of the item\n  # @param item [Item] the item that is created\n  def link_output_item(operation:, sample:, item:)\n    fv = FieldValue.new(\n      name: PRIMER_MIX,\n      child_item_id: item.id,\n      child_sample_id: sample.id,\n      role: 'output',\n      parent_class: 'Operation',\n      parent_id: operation.id,\n      field_type_id: operation.output(PRIMER_MIX).field_type.id\n    )\n    fv.save\n  end\n\n  # Instructions for suspending dried reagents\n  def suspend_primer_mix\n    show do\n      title 'Suspend Primer Mix'\n      warning 'These reagents should only be handled in a clean area.'\n      warning 'Avoid reeze-thaw cycles. Maintain on ice when thawed.'\n      check \"Using aseptic technique, suspend each dried primer in \\\n             #{qty_display(VOL_WATER)} of nuclease-free water.\"\n      check \"Rehydrate for #{qty_display(TIME_REHYDRATE)} at room temperature \\\n            in the dark.\"\n      timer initial: { minutes: TIME_REHYDRATE[:qty] }\n    end\n  end\n\n  # Make 5 aliquots for each primer\n  # @param operations [OperationList] Array of operations grouped by primer\n  def make_aliquots(ops:, primer:)\n    last_tube_id = '' # keep one of each primer\n    ops.each do |op|\n      input_primers = Array.new(OUTPUT_ITEMS_NUM[:qty], primer.id)\n      aliquot_tubes = op.outputs.map { |output| output.item.id }\n      transfer_table = Table.new\n                            .add_column('Primer Mix ID', input_primers)\n                            .add_column('Destination Tube ID', aliquot_tubes)\n\n      show do\n        title 'Make Aliquots'\n        check 'Label destination tube IDs according to the table.'\n        check \"Mix solution gently and aliquot #{qty_display(VOL_SUSPENSION)} \\\n              of rehydrated primer into each tube according to the table.\"\n        table transfer_table\n      end\n\n      primer.mark_as_deleted # discard the input\n      last_tube_id = aliquot_tubes[-1]\n    end\n\n    # One aliquot of each primer mix should be stored in the cold room instead\n    # of freezer. However, this code doesn't actually work as one ObjectType\n    # can only be associated with one location.\n    # Leaving this here for completeness.\n    last_tube = Item.find(last_tube_id)\n    last_tube.move(COLD_ROOM)\n    last_tube.store\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# frozen_string_literal: true\n\nclass ProtocolTest \u003c ProtocolTestBase\n  def setup\n    add_random_operations(1)\n  end\n\n  def analyze\n    log('Hello from Nemo')\n    assert_equal(@backtrace.last[:operation], 'complete')\n  end\nend","timing":null}},{"sample_types":[{"id":2,"name":"Respiratory Specimen","description":"Incoming sample for testing","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","field_types":[{"id":3,"parent_id":2,"name":"Tracking ID","ftype":"string","choices":null,"array":false,"required":true,"created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]},{"id":1,"name":"RNA","description":"A sample of RNA","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","field_types":[]}],"object_types":[{"id":6,"name":"Patient Swab","description":"Nasopharyngeal Swab","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:05:53.000-07:00","unit":"each","cost":0.01,"release_method":"return","release_description":"","sample_type_id":2,"image":"","prefix":"M80","rows":null,"columns":null,"sample_type_name":"Respiratory Specimen"},{"id":4,"name":"Purified RNA in 1.5 mL tube","description":"Purified RNA in 1.5 mL tube","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","unit":"RNA","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":null,"prefix":"M80","rows":null,"columns":null,"sample_type_name":"RNA"}],"operation_type":{"name":"Extract RNA","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Specimen","sample_types":["Respiratory Specimen"],"object_types":["Patient Swab"],"part":false,"array":false,"routing":"S","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Specimen","sample_types":["RNA"],"object_types":["Purified RNA in 1.5 mL tube"],"part":false,"array":false,"routing":"T","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# frozen_string_literal: true\n\nneeds 'Diagnostic RT-qPCR/RNAExtractionHelper'\n\n# Extract RNA Protocol\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass Protocol\n  include RNAExtractionHelper\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {\n      rna_extraction_kit: QiagenRNeasyMiniKit::NAME\n    }\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {\n      sample_volume: { qty: 300, units: MICROLITERS }\n    }\n  end\n\n  ########## MAIN ##########\n\n  def main\n    setup_test_options(operations: operations) if debug\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n    return {} if operations.errored.any?\n\n    operations.retrieve.make\n\n    set_kit(name: @job_params[:rna_extraction_kit])\n\n    sample_volumes = operations.map { |op| sample_volume(op) }\n    if sample_volumes.uniq.length == 1\n      run_rna_extraction_kit(\n        operations: operations,\n        sample_volume: sample_volumes.first\n      )\n    else\n      run_rna_extraction_kit(\n        operations: operations,\n        use_operations: true\n      )\n    end\n\n    operations.store\n\n    {}\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# frozen_string_literal: true\n\nclass ProtocolTest \u003c ProtocolTestBase\n  def setup\n    add_random_operations(1)\n  end\n\n  def analyze\n    log('Hello from Nemo')\n    assert_equal(@backtrace.last[:operation], 'complete')\n  end\nend\n","timing":null}},{"sample_types":[],"object_types":[{"id":22,"name":"96 deepwell plate","description":"96 deepwell plate","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-26T09:02:42.000-07:00","unit":"each","cost":0.01,"release_method":"return","release_description":"","sample_type_id":null,"image":null,"prefix":"","rows":8,"columns":12,"sample_type_name":null}],"operation_type":{"name":"Extract RNA HTP","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Specimen","sample_types":[null],"object_types":["96 deepwell plate"],"part":false,"array":false,"routing":"S","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Specimen","sample_types":[],"object_types":[],"part":false,"array":false,"routing":"T","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# frozen_string_literal: true\n\nneeds 'Diagnostic RT-qPCR/RNAExtractionHelper'\n\n# Extract RNA Protocol\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass Protocol\n  include RNAExtractionHelper\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {\n      rna_extraction_kit: TestRNAExtractionKit::NAME\n    }\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {\n      sample_volume: { qty: 300, units: MICROLITERS }\n    }\n  end\n\n  ########## MAIN ##########\n\n  def main\n    setup_test_options(operations: operations) if debug\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n    return {} if operations.errored.any?\n\n    operations.retrieve.make\n\n    set_kit(name: @job_params[:rna_extraction_kit])\n\n    sample_volumes = operations.map { |op| sample_volume(op) }\n    if sample_volumes.uniq.length == 1\n      run_rna_extraction_kit(\n        operations: operations,\n        sample_volume: sample_volumes.first\n      )\n    else\n      run_rna_extraction_kit(\n        operations: operations,\n        use_operations: true\n      )\n    end\n\n    operations.store\n\n    {}\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# test","timing":null}},{"sample_types":[{"id":10,"name":"Master Mix","description":"Master Mix sample type TODO Make better description","created_at":"2020-06-29T10:15:28.000-07:00","updated_at":"2020-06-29T10:15:28.000-07:00","field_types":[]},{"id":9,"name":"Primer/Probe Mix","description":"Primer/Probe Mix for qPCR","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-26T09:02:42.000-07:00","field_types":[]}],"object_types":[{"id":18,"name":"96-well qPCR Plate","description":"96-well qPCR Reaction","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-29T10:26:41.000-07:00","unit":"qPCR Reaction","cost":0.01,"release_method":"return","release_description":"","sample_type_id":3,"image":"","prefix":"","rows":8,"columns":12,"sample_type_name":"qPCR Reaction"},{"id":21,"name":"Primer Mix Aliquot","description":"Primer Mix Aliquot","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-26T09:02:42.000-07:00","unit":"Primer Mix","cost":0.01,"release_method":"return","release_description":"","sample_type_id":9,"image":null,"prefix":"M20","rows":null,"columns":null,"sample_type_name":"Primer/Probe Mix"}],"operation_type":{"name":"Prepare Master Mix","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"output","name":"PCR Plate","sample_types":["Master Mix"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"input","name":"Primer/Probe Mix","sample_types":["Primer/Probe Mix"],"object_types":["Primer Mix Aliquot"],"part":false,"array":true,"routing":"M","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Standard Libs/PlanParams'\nneeds 'Standard Libs/CommonInputOutputNames'\nneeds 'Standard Libs/Debug'\nneeds 'Standard Libs/Pipettors'\nneeds 'Standard Libs/LabwareNames'\nneeds 'Collection Management/CollectionActions'\nneeds 'Collection Management/CollectionDisplay'\nneeds 'Microtiter Plates/PlateLayoutGenerator'\nneeds 'PCR Libs/PCRComposition'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\n\n# Protocol for setting up a master mix plate for RT-qPCR\n# @note Instructions adapted from the CDC COVID-19 detection protocol\n#   https://www.fda.gov/media/134922/download\n#\n# 1) In the reagent set-up room clean hood, place rRT-PCR buffer, enzyme,\n#     and primer/probes on ice or cold-block. Keep cold during preparation\n#     and use.\n#\n# 2) Mix buffer, enzyme, and primer/probes by inversion 5 times.\n#\n# 3) Centrifuge reagents and primers/probes for 5 seconds to collect\n#     contents at the bottom of the tube, and then place the tube in\n#     a cold rack.\n#\n# 4) Label one 1.5 mL microcentrifuge tube for each primer/probe set.\n#\n# 5) Determine the number of reactions (N) to set up per assay.\n#   It is necessary to make excess reaction mix for the NTC, nCoVPC,\n#   HSC (if included in the RT-PCR run), and RP reactions and for pipetting\n#   error. Use the following guide to determine N:\n#     - If number of samples (n) including controls equals 1 through 14,\n#       then N = n + 1\n#     - If number of samples (n) including controls is 15 or greater,\n#       then N = n + 2\n#\n# 7) For each primer/probe set, calculate the amount of each reagent\n#   to be added for each reaction mixture (N = # of reactions).\n#\n# 8) Dispense reagents into each respective labeled 1.5 mL microcentrifuge\n#   tube. After addition of the reagents, mix reaction mixtures by\n#   pipetting up and down. Do not vortex.\n#\n# 9) Centrifuge for 5 seconds to collect contents at the bottom of\n#   the tube, and then place the tube in a cold rack.\n#\n# 10) Set up reaction strip tubes or plates in a 96-well cooler rack.\n#\n# 11) Dispense 15 uL of each master mix into the appropriate wells going\n#   across the row\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass Protocol\n  # Standard Libs\n  include PlanParams\n  include CommonInputOutputNames\n  include Debug\n  include Pipettors\n  include LabwareNames\n\n  # Collection Management\n  include CollectionActions\n  include CollectionDisplay\n\n  # Diagnostic RT-qPCR\n  include DataAssociationKeys\n\n  WATER = 'Molecular Grade Water'\n  RNA_FREE_WORKSPACE = 'reagent set-up room'\n  PLATE = 'PCR Plate'\n  PRIMER_MIX = 'Primer/Probe Mix'\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {}\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {\n      number_of_reactions: 24,\n      group_size: 3,\n      program_name: 'CDC_TaqPath_CG'\n    }\n  end\n\n  ########## MAIN ##########\n\n  def main\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n    return {} if operations.errored.any?\n\n    update_operation_params(\n      operations: operations,\n      default_operation_params: default_operation_params\n    )\n\n    provision_plates(\n      operations: operations,\n      object_type: '96-well qPCR Plate'\n    )\n\n    prepare_materials(operations: operations)\n\n    prepare_master_mixes(operations: operations)\n\n    operations.store\n\n    {}\n  end\n\n  # @todo make this responsive to the designated object_type for the operation\n  def provision_plates(operations:, object_type:)\n    operations.each do |op|\n      collection = make_new_plate(object_type, label_plate: true)\n      op.output(PLATE).set collection: collection\n      inspect op.output(PLATE).collection.matrix if debug\n    end\n  end\n\n  # Prepare workspace and materials\n  #\n  # @todo Make this handle master mix or enzyme with separate buffer dynamically\n  # @param operations [OperationList]\n  def prepare_materials(operations:)\n    prepare_workspace\n    operations.retrieve\n    mix_and_spin_down_reagents\n  end\n\n  def prepare_master_mixes(operations:)\n    operations.each { |op| prepare_master_mix(operation: op) }\n  end\n\n  def prepare_master_mix(operation:)\n    primer_mixes = operation.input_array(PRIMER_MIX).map(\u0026:item)\n    output_collection = operation.output(PLATE).collection\n\n    label_master_mix_tubes(labels: primer_mixes.map { |item| item.sample.name })\n\n    group_size = operation.temporary[:options][:group_size]\n    program_name = operation.temporary[:options][:program_name]\n    composition = PCRCompositionFactory.build(\n      program_name: program_name\n    )\n\n    output_collection.associate(COMPOSITION_NAME_KEY, program_name)\n    output_collection.associate(GROUP_SIZE_KEY, group_size)\n\n    pipet_master_mix_components(\n      primer_mixes: primer_mixes,\n      composition: composition,\n      sample_number: sample_number_with_excess(sample_number: group_size)\n    )\n\n    layout_generator = PlateLayoutGeneratorFactory.build(\n      group_size: group_size,\n      method: :primer_layout\n    )\n    primer_mixes.each do |primer_mix|\n      pipet_master_mix(\n        primer_mix: primer_mix,\n        volume: composition.sum_added_components,\n        layout_group: layout_generator.next_group,\n        collection: output_collection\n      )\n    end\n\n    # test_layout_generator(layout_generator) if debug\n  end\n\n  def sample_number_with_excess(sample_number:)\n    sample_number \u003c 15 ? sample_number + 1 : sample_number + 2\n  end\n\n  ########## SHOW METHODS ##########\n\n  def prepare_workspace\n    show do\n      title 'Prepare workspace'\n\n      note \"All tasks in this protocol occur in the #{RNA_FREE_WORKSPACE}.\"\n      note 'As you retrieve reagents, place them on ice or in a cold-block.'\n    end\n  end\n\n  def mix_and_spin_down_reagents\n    show do\n      title 'Mix and spin down reagents'\n\n      note 'Mix buffer, enzyme, and primer/probes by inversion 5 times.'\n      note 'Centrifuge reagents and primers/probes for 5 seconds to collect' \\\n        'contents at the bottom of the tube.'\n      note 'Place the tubes on ice or in a cold-block.'\n    end\n  end\n\n  def label_master_mix_tubes(labels:)\n    n = labels.length\n    labels = labels.map { |label| \"\u003cb\u003e#{label}\u003c/b\u003e\" }\n    show do\n      title 'Label master mix tubes'\n\n      note \"Take out #{n} #{TUBE_MICROFUGE.pluralize(n)}\"\n      note \"Write #{labels.to_sentence} on the tops of each tube\"\n    end\n  end\n\n  def pipet_master_mix_components(primer_mixes:, composition:, sample_number:)\n    show do\n      title 'Pipet master mix components'\n\n      note 'Pipet the following components into each labeled master mix tube'\n      table master_mix_table(\n        composition: composition,\n        sample_number: sample_number\n      )\n      separator\n\n      note 'Pipet the primer/probe mixes into each corresponding' \\\n        ' master mix tube'\n      table primer_probe_table(\n        primer_mixes: primer_mixes,\n        composition: composition,\n        sample_number: sample_number\n      )\n    end\n  end\n\n  # Build table for volumes of master mix components\n  #\n  # @param composition [PCRComposition]\n  # @param sample_number [Fixnum]\n  # @return [Array\u003cArray\u003e] a 2D array formatted for the `table` method in Krill\n  def master_mix_table(composition:, sample_number:)\n    header = [\n      'Component',\n      composition.master_mix.display_name,\n      composition.water.display_name\n    ]\n    row = [\n      \"Volume (#{MICROLITERS})\",\n      composition.master_mix.add_in_table(sample_number),\n      composition.water.add_in_table(sample_number)\n    ]\n    [header, row].transpose\n  end\n\n  # Build table for volumes of master mix components\n  #\n  # @param composition [PCRComposition]\n  # @param sample_number [Fixnum]\n  # @return [Array\u003cArray\u003e] a 2D array formatted for the `table` method in Krill\n  def primer_probe_table(primer_mixes:, composition:, sample_number:)\n    table = [[\n      composition.primer_probe_mix.display_name,\n      'Item',\n      \"Volume (#{MICROLITERS})\"\n    ]]\n    primer_mixes.each do |primer_mix|\n      row = [\n        primer_mix.sample.name,\n        primer_mix.to_s,\n        composition.primer_probe_mix.add_in_table(sample_number)\n      ]\n      table.append(row)\n    end\n    table\n  end\n\n  def pipet_master_mix(primer_mix:, volume:, layout_group:, collection:)\n    show do\n      title \"Pipet #{primer_mix.sample.name} master mix into plate\"\n\n      note \"Pipet #{volume} #{MICROLITERS} of #{primer_mix.sample.name}\" \\\n        \" master mix into the plate #{collection}\"\n      table highlight_collection_rc(collection, layout_group, check: false)\n    end\n  end\n\n  ########## TEST METHODS ##########\n\n  # @todo this doesn't work because next_group is destructive\n  def test_layout_generator(layout_generator)\n    3.times do |i|\n      inspect layout_generator.next_group.to_s, \"Layout group #{i + 1}\"\n    end\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# frozen_string_literal: true\n\nclass ProtocolTest \u003c ProtocolTestBase\n  def setup\n    add_random_operations(1)\n\n  #   mm = Sample.find_by_name('TaqPath 1-Step RT-qPCR Master Mix')\n  #   p1 = Sample.find_by_name('2019-nCoV_N1')\n  #   p2 = Sample.find_by_name('2019-nCoV_N2')\n  #   p3 = Sample.find_by_name('RNase P')\n\n  #   add_operation\n  #     .with_property(\"Options\", '{ \"magic_number\": 24, \"foo\": \"baz\" }')\n  #     .with_input('Enzyme Master Mix', mm)\n  #     .with_input('Primer/Probe Mix', p1)\n  #     .with_input('Primer/Probe Mix', p2)\n  #     .with_input('Primer/Probe Mix', p3)\n  end\n\n  def analyze\n    log('Hello from Nemo')\n    assert_equal(@backtrace.last[:operation], 'complete')\n  end\nend","timing":null}},{"sample_types":[{"id":1,"name":"RNA","description":"A sample of RNA","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","field_types":[]},{"id":2,"name":"Respiratory Specimen","description":"Incoming sample for testing","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","field_types":[{"id":3,"parent_id":2,"name":"Tracking ID","ftype":"string","choices":null,"array":false,"required":true,"created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]},{"id":10,"name":"Master Mix","description":"Master Mix sample type TODO Make better description","created_at":"2020-06-29T10:15:28.000-07:00","updated_at":"2020-06-29T10:15:28.000-07:00","field_types":[]},{"id":3,"name":"qPCR Reaction","description":"qPCR Reaction","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","field_types":[]}],"object_types":[{"id":4,"name":"Purified RNA in 1.5 mL tube","description":"Purified RNA in 1.5 mL tube","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","unit":"RNA","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":null,"prefix":"M80","rows":null,"columns":null,"sample_type_name":"RNA"},{"id":5,"name":"Eluted Swab","description":"A Respiratory Specimen that has been rehydrated with reydration buffer","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:05:42.000-07:00","unit":"Respiratory Specimen","cost":0.01,"release_method":"return","release_description":"","sample_type_id":2,"image":"","prefix":"","rows":null,"columns":null,"sample_type_name":"Respiratory Specimen"},{"id":18,"name":"96-well qPCR Plate","description":"96-well qPCR Reaction","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-29T10:26:41.000-07:00","unit":"qPCR Reaction","cost":0.01,"release_method":"return","release_description":"","sample_type_id":3,"image":"","prefix":"","rows":8,"columns":12,"sample_type_name":"qPCR Reaction"}],"operation_type":{"name":"Prepare RT-qPCR Plate","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Template","sample_types":["RNA","Respiratory Specimen"],"object_types":["Purified RNA in 1.5 mL tube","Eluted Swab"],"part":false,"array":true,"routing":"T","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"input","name":"PCR Plate","sample_types":["Master Mix"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":14,"preferred_field_type_id":39,"choices":null},{"ftype":"sample","role":"output","name":"PCR Plate","sample_types":["qPCR Reaction"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"string","role":"input","name":"Assay Type","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":"Modified_CDC,Standard_CDC"}],"protocol":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Diagnostic RT-qPCR/DiagnosticRTqPCRHelper'\nneeds 'Diagnostic RT-qPCR/DiagnosticRTqPCRDebug'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\nneeds 'PCR Libs/PCRComposition'\nneeds 'Microtiter Plates/MicrotiterPlate'\nneeds 'Collection Management/CollectionTransfer'\n\n# Protocol for setting up a plate with extracted RNA samples\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n# @author Cannon Mallory \u003cmalloc3@uw.edu\u003e\nclass Protocol\n  include DiagnosticRTqPCRHelper\n  include DiagnosticRTqPCRDebug\n  include MicrotiterPlates\n  include CollectionTransfer\n  include DataAssociationKeys\n\n  \n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {\n      max_inputs: 24,\n      method: 'cdc_sample_layout'.to_sym\n    }\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {\n      negative_template_control: nil,\n      negative_template_location: nil,\n      positive_template_control: 'Test nCoVPC',\n      positive_template_location: [0, 11]\n    }\n  end\n\n  def main\n    #========= Setup Job ==========#\n    setup_test(operations) if debug\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n\n    #========= Validation =========#\n    validate(operations: operations)\n    return {} if operations.errored.any?\n\n    #====== General Warnings =====#\n    rnase_warning\n    safety_warning\n\n    operations.retrieve.make\n\n    #====== Core Operation ======#\n    operations.each do |op|\n      op.pass(PLATE)\n      output_collection = op.output(PLATE).collection\n      group_size = output_collection.get(:group_size)\n      program_name = output_collection.get(:program_name)\n\n      microtiter_plate = MicrotiterPlateFactory.build(\n        collection: output_collection,\n        group_size: group_size,\n        method: op.temporary[:options][:method]\n      )\n\n      composition = PCRCompositionFactory.build(\n        program_name: program_name\n      )\n      volume = { qty: composition.template.qty,\n                 units: composition.template.units }\n\n      remaining_inputs = add_control_samples(\n        operation_inputs: op.input_array(TEMPLATE),\n        microtiter_plate: microtiter_plate,\n        volume: volume,\n        operation_parameters: op.temporary[:options]\n      )\n\n      add_diagnostic_samples(\n        operation_inputs: remaining_inputs,\n        microtiter_plate: microtiter_plate,\n        volume: volume\n      )\n\n      seal_plate(output_collection)\n      show_result(collection: output_collection) if debug\n    end\n\n    operations.store\n\n    {}\n  end\n\n  # Provides instructions and handling for addition of control\n  # samples.  Returns all inputs that are NOT control inputs\n  #\n  # @param operation_inputs [Array\u003citem\u003e]\n  # @param collection [Collection]\n  # @param layout_generator [LayoutGenerator]\n  # @param volume [{aty: int, unit: string}]\n  # @return operation_inputs [Array\u003citem\u003e]\n  def add_control_samples(operation_inputs:, microtiter_plate:,\n                          volume:, operation_parameters:)\n    %w[negative_template positive_template].each do |stub|\n      name = operation_parameters[\"#{stub}_control\".to_sym]\n      loc = operation_parameters[\"#{stub}_location\".to_sym]\n\n      next unless name.present? \u0026\u0026 loc.present?\n\n      control_inputs, operation_inputs = operation_inputs.partition do |fv|\n        fv.sample.name == name\n      end\n\n      add_samples(\n        operation_inputs: control_inputs,\n        microtiter_plate: microtiter_plate,\n        volume: volume,\n        column: loc[1]\n      )\n\n      # negative control samples need to be covered after addition\n      next unless stub.include?('negative')\n\n      seal_plate(collection, rc_list: get_rna_samples(collection))\n    end\n    operation_inputs\n  end\n\n  # Provides instructions to add diagnostic samples to collection\n  #\n  # @param operation_inputs [Array\u003citems\u003e]\n  # @param collection [Collection]\n  # @param layout_generator [LayoutGenerator]\n  # @param volume [{aty: int, unit: string}]\n  def add_diagnostic_samples(operation_inputs:, microtiter_plate:,\n                            volume:)\n    add_samples(\n      operation_inputs: operation_inputs,\n      microtiter_plate: microtiter_plate,\n      volume: volume\n    )\n  end\n\n  # validates operations and ensures that they are formatted as expected\n  #\n  # @param operations [OperationList]\n  def validate(operations:)\n    operations.each do |op|\n      if op.input_array(TEMPLATE).length \u003e @job_params[:max_inputs]\n        raise IncompatibleInputsError, \"Too many inputs for Operation #{op.id}\"\n      end\n    end\n  rescue IncompatibleInputsError =\u003e e\n    error_operations(operations: operations, err: e)\n  end\n\n  # Say you're quitting due to an error and error all the operations\n  #\n  def error_operations(operations:, err:)\n    show do\n      title 'Incompatible Inputs Detected'\n      warning err.message\n    end\n\n    operations.each { |op| op.error(:incompatible_inputs, err.message) }\n  end\n\n  class IncompatibleInputsError \u003c ProtocolError; end\n  class NoAvailableWells \u003c ProtocolError; end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"class ProtocolTest \u003c ProtocolTestBase\n    def setup\n      add_random_operations(1)\n    end\n  \n    def analyze\n      log('Hello from Nemo')\n      assert_equal(@backtrace.last[:operation], 'complete')\n    end\n  end","timing":null}},{"sample_types":[{"id":3,"name":"qPCR Reaction","description":"qPCR Reaction","created_at":"2020-06-26T09:01:19.000-07:00","updated_at":"2020-06-26T09:01:19.000-07:00","field_types":[]}],"object_types":[{"id":18,"name":"96-well qPCR Plate","description":"96-well qPCR Reaction","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-06-26T09:02:42.000-07:00","updated_at":"2020-06-29T10:26:41.000-07:00","unit":"qPCR Reaction","cost":0.01,"release_method":"return","release_description":"","sample_type_id":3,"image":"","prefix":"","rows":8,"columns":12,"sample_type_name":"qPCR Reaction"}],"operation_type":{"name":"Run qPCR","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"qPCR Reactions","sample_types":["qPCR Reaction"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"qPCR Reactions","sample_types":["qPCR Reaction"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# frozen_string_literal: true\n\nneeds 'PCR Libs/PCRComposition'\nneeds 'PCR Libs/PCRProgram'\nneeds 'Thermocyclers/Thermocyclers'\nneeds 'Standard Libs/PlanParams'\nneeds 'Standard Libs/Debug'\n\n# Protocol for loading samples into a qPCR thermocycler and running it\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n# @todo Decide whether this is actually qPCR specific\nclass Protocol\n  include ThermocyclerHelper\n  include PlanParams\n  include Debug\n\n  INPUT_REACTIONS = 'qPCR Reactions'\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {\n      thermocycler_model: TestThermocycler::MODEL,\n      program_name: 'CDC_TaqPath_CG',\n      qpcr: true\n    }\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {}\n  end\n\n  ########## MAIN ##########\n\n  def main\n    setup_test_options(operations: operations) if debug\n\n    @job_params = update_job_params(\n      operations: operations,\n      default_job_params: default_job_params\n    )\n    return {} if operations.errored.any?\n\n    operations.retrieve.make\n\n    composition = PCRCompositionFactory.build(\n      program_name: @job_params[:program_name]\n    )\n    program = PCRProgramFactory.build(\n      program_name: @job_params[:program_name],\n      volume: composition.volume\n    )\n    thermocycler = ThermocyclerFactory.build(\n      model: @job_params[:thermocycler_model]\n    )\n\n    set_up_program(\n      thermocycler: thermocycler,\n      program: program,\n      composition: composition,\n      qpcr: @job_params[:qpcr]\n    )\n\n    load_plate_and_start_run(\n      thermocycler: thermocycler,\n      items: operations.map { |op| op.input(INPUT_REACTIONS).item },\n      experiment_filename: experiment_filename\n    )\n\n    export_measurements(thermocycler: thermocycler)\n\n    operations.store\n\n    {}\n  end\n\n  ########## NAMING METHODS ##########\n\n  # Constructs a name for the experiment file.\n  #\n  # @return [String]\n  def experiment_filename\n    date = DateTime.now.strftime('%Y-%m-%d')\n    \"#{date}_Job_#{job.id}\"\n  end\n\n  # Gets the currently active `Job`\n  #\n  # @return [Job]\n  def job\n    operation_ids = operations.map(\u0026:id)\n    ja_ids = JobAssociation.where(operation_id: operation_ids).map(\u0026:job_id).uniq\n    jobs = Job.find(ja_ids).select(\u0026:active?)\n    raise ProtocolError, 'Cannot resolve the current Job' if jobs.length \u003e 1\n\n    jobs.last\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# frozen_string_literal: true\n\nclass ProtocolTest \u003c ProtocolTestBase\n  def setup\n    add_random_operations(1)\n    # [1..3].each do |i|\n    #   s = Sample.find_by_name(\"Test qPCR Reaction #{i}\")\n    #   add_operation\n    #     .with_input('qPCR Reactions', s)\n    #     .with_property('Options', '{\"thermocycler_model\": \"BioRad CFX96\", \"program_name\": \"CDC_qScript_XLT_ToughMix\"}')\n    #     .with_output('qPCR Reactions', s)\n    # end\n  end\n\n  def analyze\n    log('Hello from Nemo')\n    assert_equal(@backtrace.last[:operation], 'complete')\n  end\nend\n","timing":null}},{"library":{"name":"DataAssociationKeys","category":"Diagnostic RT-qPCR","code_source":"module DataAssociationKeys\n  GROUP_SIZE_KEY = 'group_size'\n  COMPOSITION_NAME_KEY = 'composition_name'\n  TEMPLATE_KEY = 'template'\nend"}},{"library":{"name":"DiagnosticRTqPCRDebug","category":"Diagnostic RT-qPCR","code_source":"# typed: false\n# frozen_string_literal: true\nneeds 'Collection Management/CollectionTransfer'\nneeds 'Diagnostic RT-qPCR/DiagnosticRTqPCRHelper'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\n\nmodule DiagnosticRTqPCRDebug\n  include CollectionTransfer\n  include DiagnosticRTqPCRHelper\n  include DataAssociationKeys\n\n  VERBOSE = false\n\n  def debug_parameters\n    {\n      group_size: 3,\n      program_name: 'CDC_TaqPath_CG',\n      debug_primer: [5, 8, 9], # rp, n1, n2,\n      debug_template: 'template',\n      debug_items: [257,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256,\n                    256]\n    }\n  end\n\n  def setup_test(operations)\n    operations.each do |op|\n      setup_test_plate(collection: op.input('PCR Plate').collection)\n      op.set_input('Template', generate_samples(debug_parameters[:debug_items]))\n    end\n  end\n\n  # Populate test plate with qPCR Reactions and one no template control (NTC)\n  #\n  def setup_test_plate(collection:)\n    verbose = false\n    key = TEMPLATE_KEY\n    collection.associate(:program_name, debug_parameters[:program_name])\n    collection.associate(:group_size, debug_parameters[:group_size])\n    qpcr_reaction = Sample.find_by_name('Test qPCR Reaction')\n    ntc_item = Item.find(258)\n    layout_generator = PlateLayoutGeneratorFactory.build(\n      group_size: debug_parameters[:group_size],\n      method: :cdc_sample_layout\n    )\n    i = 0\n    loop do\n      layout_group = layout_generator.next_group\n      break unless layout_group.present?\n      layout_group.each do |r, c|\n        collection.set(r, c, qpcr_reaction)\n        next if i.positive?\n        part = collection.part(r, c)\n        inspect part, \"part at #{[r, c]}\" if verbose\n        part.associate(key, ntc_item)\n        inspect part.associations, \"#{key} at #{[r, c]}\" if verbose\n      end\n      i += 1\n    end\n    show_result(collection: collection) if verbose\n    inspect collection.parts.to_s if verbose\n  end\n\n  def generate_samples(debug_item_ids)\n    debug_items = []\n    debug_item_ids.each do |id|\n      debug_items.push(Item.find(id))\n    end\n    debug_items\n  end\n\n  def show_result(collection:)\n    show do\n      table highlight_non_empty(collection)\n    end\n  end\n\nend\n\n\n\n#   def setup_test(operations)\n#     operations.each do |op|\n#       op.input('PCR Plate').set(collection: generate_debug_container)\n#       op.set_input('Template', generate_samples(debug_parameters[:debug_items]))\n#     end\n#   end\n\n#   # TODO: this is pretty gross and hard coded yuck\n#   def generate_debug_container\n#     obj_type = ObjectType.find_by_name('96-well qPCR Plate')\n#     collection = Collection.new_collection(obj_type)\n#     collection.associate(:program_name, debug_parameters[:program_name])\n#     collection.associate(:group_size, debug_parameters[:group_size])\n\n#     add_primer_probe(collection)\n#     add_neg_control(collection)\n\n#     raise \"the associations are #{collection.part(0,0).associations}\"\n#     collection\n#   end\n\n#   def add_primer_probe(collection)\n#     debug_parameters[:debug_primer].each_with_index do |sample, idx|\n#       sample = Sample.find(sample)\n#       12.times do |col|\n#         row1 = 0 + idx\n#         row2 = 4 + idx\n#         collection.set(row1, col, sample)\n#         collection.set(row2, col, sample)\n#       end\n#     end\n#   end\n\n#   def add_neg_control(collection)\n#     microtiter_plate = MicrotiterPlateFactory.build(\n#       collection: collection,\n#       group_size: debug_parameters[:group_size],\n#       method: :sample_layout\n#     )\n#     item = Item.find(debug_parameters[:neg_control_sample])\n#     neg_group = microtiter_plate.next_empty(key: TEMPLATE_KEY)\n\n#     association_map = []\n#     neg_group.each { |r, c| association_map.push({ to_loc: [r, c] }) }\n#     transfer_from_item_to_collection(from_item: item,\n#                                      to_collection: microtiter_plate.collection,\n#                                      association_map: association_map,\n#                                      transfer_vol: { qty: 5, units: 'ul'})\n#     neg_group.each { |nxt| associate(index: nxt, key: TEMPLATE_KEY, data: item.id) }\n#   end\n\n#   def generate_samples(debug_item_ids)\n#     debug_items = []\n#     debug_item_ids.each do |id|\n#       debug_items.push(Item.find(id))\n#     end\n#     debug_items\n#   end\n# end\n"}},{"library":{"name":"DiagnosticRTqPCRHelper","category":"Diagnostic RT-qPCR","code_source":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Standard Libs/PlanParams'\nneeds 'Standard Libs/CommonInputOutputNames'\nneeds 'Standard Libs/Debug'\nneeds 'Standard Libs/Pipettors'\nneeds 'Standard Libs/LabwareNames'\nneeds 'Collection Management/CollectionActions'\nneeds 'Collection Management/CollectionDisplay'\nneeds 'Collection Management/CollectionTransfer'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\n\n# Module for elements that are common throughout Diagnostic RT qPCR\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nmodule DiagnosticRTqPCRHelper\n  # Standard Libs\n  include Units\n  include PlanParams\n  include CommonInputOutputNames\n  include Debug\n  include Pipettors\n  include LabwareNames\n\n  # Collection Management\n  include CollectionActions\n  include CollectionDisplay\n  include CollectionTransfer\n\n  #Diagnostic RT-qPCR\n  include DataAssociationKeys\n\n  WATER = 'Molecular Grade Water'\n  RNA_FREE_WORKSPACE = 'reagent set-up room'\n  PLATE = 'PCR Plate'\n  PRIMER_MIX = 'Primer/Probe Mix'\n  TEMPLATE = 'Template'\n\n  def rnase_warning\n    show do\n      title 'RNase degrades RNA'\n      note 'RNA is prone to degradation by RNase present in our eyes, skin, and breath.'\n      note 'Avoid opening tubes outside the Biosafety Cabinet (BSC).'\n      bullet 'Change gloves whenever you suspect potential RNAse contamination'\n    end\n  end\n\n  def safety_warning\n    show do\n      title 'Review Safety Warnings'\n      note '\u003cb\u003eAlways\u003c/b\u003e pay attention to orange warning blocks throughout the protocol.'\n      warning '\u003cb\u003eINFECTIOUS MATERIALS\u003c/b\u003e'\n      note 'You will be working with infectious materials.'\n      note 'Do \u003cb\u003eALL\u003c/b\u003e work in a biosafety cabinet (BSC).'\n      note '\u003cb\u003ePPE is required\u003c/b\u003e'\n      check 'Put on lab coat.'\n      check 'Put on 2 layers of gloves.'\n      bullet 'Make sure to use tight gloves. Tight gloves reduce the chance of the gloves getting caught on the tubes when closing their lids.'\n      bullet 'Change outer layer of gloves after handling infectious sample and before touching surfaces outside of the BSC (such as a refrigerator door handle).'\n    end\n  end\n\n  # TODO: Think about how to switch this to row-wise addition.\n  # Adds samples to to collections, provides instructions to tech\n  #\n  # @param operation_inputs [Array\u003citems\u003e]\n  # @param collection [Collection]\n  # @param layout_generator [LayoutGenerator]\n  # @param volume [{aty: int, unit: string}]\n  # @param column [int]\n  def add_samples(operation_inputs:, microtiter_plate:,\n                  volume:, column: nil)\n    operation_inputs.each do |fv|\n      item = fv.item\n      layout_group = microtiter_plate.associate_next_empty_group(\n        key: TEMPLATE_KEY,\n        data: { item: item.id, volume: volume },\n        column: column\n      )\n\n      association_map = []\n      layout_group.each { |r, c| association_map.push({ to_loc: [r, c] }) }\n      single_channel_item_to_collection(to_collection: microtiter_plate.collection,\n                                        source: item,\n                                        volume: volume,\n                                        association_map: association_map)\n    end\n  end\n\nend\n"}},{"library":{"name":"PrepareRTqPCRValidation","category":"Diagnostic RT-qPCR","code_source":"# frozen_string_literal: true\n\nmodule PrepareRTqPCRValidation\n\n  # Validates that all operations are as expected\n  #\n  # @param operations [OperationList] list of operations\n  # @raise rescue will Error any operations that do not pass validation\n  def validate(operation:, job_params:)\n    valid_op = true\n\n    valid_input, input_error = validate_inputs(operation, job_params)\n    valid_contents, content_error = validate_contents(operation, job_params)\n    unless valid_input\n      valid_op = false\n      operation.error(:IncompatibleInputsError, input_error)\n      display_error([{ op: operation, error: content_error }])\n    end\n\n    unless valid_contents\n      valid_op = false\n      operation.error(:InvalidContentsError, content_error)\n      display_error([{ op: operation, error: content_error }])\n    end\n\n    valid_op\n  end\n\n  def display_error(error_list)\n    error_type = error_list.first[:error]\n    tab = [['\u003cb\u003eOperation\u003cb\u003e', '\u003cb\u003eError Message\u003c/b\u003e']]\n    error_list.each do |err|\n      tab.push([err[:op].id, err[:error]])\n    end\n\n    show do\n      title 'Operation Error'\n      note \"The following operations had #{error_type}\"\n      table tab\n    end\n  end\n\n  def validate_contents(op, job_params)\n    [true, nil]\n  end\n\n  def validate_inputs(op, job_params)\n    [true, nil]\n  end\n\n  class IncompatibleInputsError \u003c ProtocolError; end\n  class InvalidContentsError \u003c ProtocolError; end\n\nend\n"}},{"library":{"name":"PrepareqPCRPlateHelper","category":"Diagnostic RT-qPCR","code_source":"# frozen_string_literal: true\n\nneeds 'PCR Libs/PCRCompositionDefinitions'\nneeds 'Collection Management/CollectionTransfer'\nneeds 'Standard Libs/WorkSpace'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\n\n# Protocol methods for setting up plate withe extracted RNA Samples\n#\n# @author Devin Strickland \u003cstrklnd@uw.edu\u003e\n# @author Cannon Mallory \u003cmalloc3@uw.edu\u003e\nmodule PrepareqPCRPlateHelper\n\n  include PCRCompositionDefinitions\n  include CollectionTransfer\n  include DataAssociationKeys\n\n  attr_reader :template\n\n  OPTIONS = 'options'\n  INPUT_PLATE = 'PCR Plate'\n  OUTPUT_PLATE = 'PCR Plate'\n  ASSAY_TYPE = 'Assay Type'\n\n  def add_inputs(collection:, samples:, volume:, station:)\n    return if samples.empty?\n\n    move_to_station(station)\n    layout_materials(samples + [collection])\n\n    samples.each do |item|\n      association_map = to_association_map(collection: collection,\n                                           item: item.sample)\n      single_channel_item_to_collection(to_collection: collection,\n                                        source: item.id,\n                                        volume: volume,\n                                        association_map: association_map)\n    end\n  end\n\n  def update_parameters(operation:,\n                        default_operation_params:,\n                        default_job_params:)\n\n    determine_default_job_params(operation: operation,\n                                 default_job_params: default_job_params)\n    opts = operation.plan.associations[:Options]\n    default_job_params.update(update_plan_params(plan_params: default_operation_params,\n                                                 opts: opts))\n  end\n\n  def determine_default_job_params(operation:, default_job_params:)\n    input_plate = operation.input(INPUT_PLATE).collection\n    default_job_params[:template] = get_composition_def(\n      name: input_plate.get(COMPOSITION_NAME_KEY))[:template]\n    @template = default_job_params[:template][:input_name]\n    group_size = input_plate.get('group_size'.to_sym).to_i\n    rows, columns = input_plate.dimensions\n    default_job_params[:group_size] = group_size\n    default_job_params[:max_inputs] = rows / group_size * columns\n  end\n\n  def setup_input_output_collections(input_collection:)\n    output_collection = exact_copy(input_collection, label_plates: false)\n    association_map = one_to_one_association_map(to_collection: output_collection,\n                                                 from_collection: input_collection)\n\n    associate_transfer_collection_to_collection(to_collection: output_collection,\n                                                from_collection: input_collection,\n                                                association_map: association_map)\n\n    relabel_plate(from_collection: input_collection,\n                  to_collection: output_collection)\n    output_collection\n  end\n\n  def sort_inputs(negative_control:, positive_control:, operation_inputs:)\n    remaining_inputs = []\n    negative_controls = []\n    positive_controls = []\n    operation_inputs.each do |input|\n      input_name = input.sample.name\n\n      if input_name.include?(negative_control)\n        negative_controls.push(input)\n      elsif input_name.include?(positive_control)\n        positive_controls.push(input)\n      else\n        remaining_inputs.push(input)\n      end\n    end\n    {negative_control: negative_controls,\n     positive_control: positive_controls,\n     standard_sample: remaining_inputs}\n  end\n\n  def setup_samples(operation_inputs:,\n                    collection:,\n                    layout_generator:,\n                    names_to_avoid: [],\n                    column: nil)\n    operation_inputs.each do |fv|\n      job_params[:max_inputs].times do\n        retry_group = true\n\n        layout_group = layout_generator.next_group(column: column)\n\n        layout_group.each do |r, c|\n          existing_part = collection.part(r, c)\n          raise \"Part #{r} , #{c}, #{layout_group}\" if existing_part.nil?\n\n          break if avoid_name(existing_part.sample.name, names_to_avoid)\n\n          collection.set(r, c, fv.sample)\n          from_obj_to_obj_provenance(collection.part(r, c), existing_part)\n          retry_group = false\n        end\n\n        column = layout_generator.iterate_column(column)\n        break unless retry_group\n      end\n    end\n  end\n\n  def avoid_name(name, names_to_avoid)\n    names_to_avoid.each do |avoid_name|\n      return true if name.include?(avoid_name)\n    end\n    false\n  end\n\n  def move_to_station(station)\n    show do\n      title 'Move to Proper Area'\n      note \"Please move to the \u003cb\u003e#{station}\u003c/b\u003e to complete the following steps\"\n    end\n  end\n\nend\n"}},{"library":{"name":"RNAExtractionHelper","category":"Diagnostic RT-qPCR","code_source":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Standard Libs/PlanParams'\nneeds 'Standard Libs/Units'\nneeds 'Standard Libs/Debug'\nneeds 'RNA Extraction Kits/RNAExtractionKits'\n\n# Module for elements that are common to RNA Extraction Protocols\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nmodule RNAExtractionHelper\n  include PlanParams\n  include Units\n  include Debug\n  include RNAExtractionKits\n\n  def sample_volume(operation)\n    operation.temporary[:options][:sample_volume]\n  end\nend\n"}}]}