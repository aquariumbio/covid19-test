{"config":{"title":"Diagnostic RT-qPCR","description":"No description given","copyright":"No copyright declared","version":"no version info","authors":[],"maintainer":{"name":"No maintainer","email":"noone@nowehere"},"acknowledgements":[],"github":{"repo":"none","user":"none","access_token":"none"},"keywords":[],"aquadoc_version":"1.0.2"},"components":[{"sample_types":[{"id":7,"name":"qPCR Reaction","description":"qPCR Reaction","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","field_types":[]}],"object_types":[{"id":8,"name":"96-well qPCR Plate","description":"96-well qPCR Reaction","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","unit":"qPCR Reaction","cost":0.01,"release_method":"return","release_description":"","sample_type_id":7,"image":null,"prefix":"","rows":8,"columns":12,"sample_type_name":"qPCR Reaction"}],"operation_type":{"name":"Add No Template Control","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"PCR Plate","sample_types":["qPCR Reaction"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":8,"preferred_field_type_id":22,"choices":null},{"ftype":"sample","role":"output","name":"PCR Plate","sample_types":["qPCR Reaction"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Standard Libs/PlanParams'\nneeds 'Standard Libs/CommonInputOutputNames'\nneeds 'Standard Libs/Debug'\nneeds 'Standard Libs/Pipettors'\nneeds 'Standard Libs/LabwareNames'\nneeds 'Collection Management/CollectionActions'\nneeds 'Collection Management/CollectionDisplay'\nneeds 'Microtiter Plates/PlateLayoutGenerator'\nneeds 'PCR Libs/PCRComposition'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\nneeds 'Microtiter Plates/MicrotiterPlates'\n\n# Protocol for setting up a master mix plate for RT-qPCR\n# @note Instructions adapted from the CDC COVID-19 detection protocol\n#   https://www.fda.gov/media/134922/download\n#\n# 12) Prior to moving to the nucleic acid handling area, prepare the\n#   No Template Control (NTC) reactions for column #1 in the\n#   assay preparation area.\n#\n# 13) Pipette 5 uL of nuclease-free water into the NTC sample wells\n#   (Figure 2, column 1). Securely cap NTC wells before proceeding.\n#\n# 14) Cover the entire reaction plate and move the reaction plate to\n#   the specimen nucleic acid handling area.\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass Protocol\n  # Standard Libs\n  include PlanParams\n  include CommonInputOutputNames\n  include Debug\n  include Pipettors\n  include LabwareNames\n\n  # Collection Management\n  include CollectionActions\n  include CollectionDisplay\n\n  # Diagnostic RT-qPCR\n  include DataAssociationKeys\n\n  WATER = 'Molecular Grade Water'\n  RNA_FREE_WORKSPACE = 'reagent set-up room'\n  PLATE = 'PCR Plate'\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {}\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {\n      program_name: 'CDC_TaqPath_CG',\n      group_size: 3,\n      layout_method: 'cdc_sample_layout'\n    }\n  end\n\n  ########## MAIN ##########\n\n  def main\n    setup_test_plates(operations: operations) if debug\n\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n    return {} if operations.errored.any?\n\n    operations.retrieve\n\n    operations.each do |op|\n      op.pass(PLATE)\n      add_no_template_controls(operation: op)\n    end\n\n    operations.store\n\n    {}\n  end\n\n  # Add the no template controls to an Operation's putput collection\n  #\n  # @param operation [Operation]\n  # @return [void]\n  def add_no_template_controls(operation:)\n    # Group_Size and Program name are attributes of the plate\n    # and should be associated to the plate from Prepare Master Mix\n    # This may not work because group size is different depending on whether\n    #   talking about samples or primers\n    # group_size = op.input(PLATE).collection.get(GROUP_SIZE_KEY)\n    # program_name = op.input(PLATE).collection.get(COMPOSITION_NAME_KEY)\n\n    collection = operation.output(PLATE).collection\n\n    layout_group = add_ntc_data(\n      collection: collection,\n      group_size: operation.temporary[:options][:group_size],\n      method: operation.temporary[:options][:layout_method]\n    )\n\n    composition = PCRCompositionFactory.build(\n      program_name: operation.temporary[:options][:program_name]\n    )\n\n    show_add_ntc(\n      collection: collection,\n      volume: composition.water.qty_display,\n      layout_group: layout_group\n    )\n\n    show_result(collection: collection) if debug\n    inspect_data_associations(collection: collection) if debug\n  end\n\n  # Add metadata for a group of no template control samples, and return the\n  #   locations of the group\n  #\n  # @param collection [Collection]\n  # @param group_size [Fixnum]\n  # @param method [String]\n  # @return [Array\u003cArray\u003cFixnum\u003e\u003e]\n  def add_ntc_data(collection:, group_size:, method:)\n    microtiter_plate = MicrotiterPlateFactory.build(\n      collection: collection,\n      group_size: group_size,\n      method: method\n    )\n\n    # TODO: Do we want to have an item number for the water?\n    microtiter_plate.associate_next_empty_group(\n      key: TEMPLATE_KEY,\n      data: WATER\n    )\n  end\n\n  # Instruct technician to add the no template control samples to the plate\n  #\n  # @param collection [Collection]\n  # @param volume [Fixnum]\n  # @param layout_group [Array\u003cArray\u003cFixnum\u003e\u003e]\n  # @return [void]\n  def show_add_ntc(collection:, volume:, layout_group:)\n    show do\n      title \"Pipet No Template Control (NTC) samples into plate #{collection}\"\n\n      note \"Pipet #{volume} of #{WATER} into the indicated wells of\" \\\n        \" plate #{collection}\"\n      table highlight_collection_rc(collection, layout_group, check: true)\n    end\n  end\n\n  ########## DEBUG METHODS ##########\n\n  # Populate all input plates with qPCR Reactions\n  #\n  # @param operations [OperationList]\n  # @return [void]\n  def setup_test_plates(operations:)\n    operations.each do |op|\n      setup_test_plate(collection: op.input(PLATE).collection)\n    end\n  end\n\n  # Populate a collection with qPCR Reactions\n  #\n  # @param collection [Collection]\n  # @return [void]\n  def setup_test_plate(collection:)\n    qpcr_reaction = Sample.find_by_name('Test qPCR Reaction')\n\n    layout_generator = PlateLayoutGeneratorFactory.build(\n      group_size: 24,\n      method: :cdc_primer_layout\n    )\n\n    loop do\n      layout_group = layout_generator.next_group\n      break unless layout_group.present?\n\n      layout_group.each do |r, c|\n        collection.set(r, c, qpcr_reaction)\n        part = collection.part(r, c)\n        part.associate(MASTER_MIX_KEY, { foo: 'bar' })\n      end\n    end\n\n    show_result(collection: collection)\n    inspect_data_associations(collection: collection)\n  end\n\n  # Show all the non-empty wells of the test plate\n  # @todo figure out what you really want to show here\n  #\n  # @param collection [Collection]\n  # @return [void]\n  def show_result(collection:)\n    show do\n      title 'Test Plate Setup'\n      table highlight_non_empty(collection)\n    end\n  end\n\n  # Inspect a subset of the parts and their data associations\n  #\n  # @param collection [Collection]\n  # @return [void]\n  def inspect_data_associations(collection:)\n    [[0, 0], [0, 3], [0, 8]].each do |r, c|\n      part = collection.part(r, c)\n      inspect part, \"part at #{[r, c]}\"\n      inspect part.associations, \"data at #{[r, c]}\"\n    end\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# frozen_string_literal: true\n\nclass ProtocolTest \u003c ProtocolTestBase\n  def setup\n    ops = add_random_operations(1)\n  end\n\n  def analyze\n    log('Hello from Nemo')\n    assert_equal(@backtrace.last[:operation], 'complete')\n  end\nend","timing":null}},{"sample_types":[{"id":1,"name":"Diagnostic Samplle","description":"Incoming sample for testing","created_at":"2020-07-07T09:04:43.000-07:00","updated_at":"2020-07-07T10:33:59.000-07:00","field_types":[]}],"object_types":[{"id":15,"name":"Lyophilized RNA","description":"Lyophilized RNA for control samples","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T10:35:54.000-07:00","updated_at":"2020-07-07T10:35:54.000-07:00","unit":"Diagnostic Samplle","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":"","prefix":"","rows":null,"columns":null,"sample_type_name":"Diagnostic Samplle"},{"id":16,"name":"Purified RNA in 1.5 ml Tube","description":"Purified RNA in a 15 ml Eppendorf tube","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T10:36:36.000-07:00","updated_at":"2020-07-07T10:36:36.000-07:00","unit":"Diagnostic Samplle","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":"","prefix":"M80","rows":null,"columns":null,"sample_type_name":"Diagnostic Samplle"}],"operation_type":{"name":"Aliquot Positive Template","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Template","sample_types":["Diagnostic Samplle"],"object_types":["Lyophilized RNA"],"part":false,"array":false,"routing":"T","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Template","sample_types":["Diagnostic Samplle"],"object_types":["Purified RNA in 1.5 ml Tube"],"part":false,"array":false,"routing":"T","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# Aliquot Positive Template\n# Written By Rita Chen 2020-05-04\n# Updated by Dany Fu 2020-06-01\n\nneeds 'Diagnostic RT-qPCR/DiagnosticRTqPCRHelper'\n\n# 2019-nCoV Positive Control (nCoVPC) Preparation:\n# 1) Precautions: This reagent should be handled with caution in a dedicated\n# nucleic acid handling area to prevent possible contamination. Freeze-thaw\n# cycles should be avoided. Maintain on ice when thawed.\n# 2) Resuspend dried reagent in each tube in 1 mL of nuclease-free water to\n# achieve the proper concentration. Make single use aliquots (approximately 30\n# uL) and store at less than and equal to -70C.\n# 3) Thaw a single aliquot of diluted positive control for each experiment and\n# hold on ice until adding to plate. Discard any unused portion of the aliquot.\nclass Protocol\n  include DiagnosticRTqPCRHelper\n\n  VOL_WATER = { qty: 1, units: MILLILITERS }.freeze\n  VOL_SUSPENSION = { qty: 30, units: MICROLITERS }.freeze\n  OUTPUT_ITEMS_NUM = { qty: 33, units: TUBE_MICROFUGE }.freeze\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {}\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {}\n  end\n\n  ########## MAIN ##########\n\n  def main\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n    return {} if operations.errored.any?\n\n    update_operation_params(\n      operations: operations,\n      default_operation_params: default_operation_params\n    )\n\n    # 1. Get 33 1.5 mL tube for each operation\n    get_tubes(count: operations.length)\n    operations.retrieve\n\n    # 2. For each Lyophilized Postive Control, resuspend in 1 mL of\n    # nuclease-free waterand, aliquot 33 use aliquots (approximately\n    # 30 uL) and store at less than and equal to -70C.\n    save_output(ops: operations)\n\n    suspend_lyophilized_RNA\n    keep_tubes = [] # Empty array for storing single use aliquots\n\n    # Group the operations by the input reagent\n    ops_by_input = operations.group_by { |op| op.input(TEMPLATE).item }\n    ops_by_input.each do |lyophilized_rna, ops|\n      keep_tubes.push(make_aliquots(ops: ops, lyophilized_rna: lyophilized_rna))\n    end\n\n    prepare_plating(keep_tubes: keep_tubes)\n\n    # 3. Thaw a single aliquot of diluted positive control for each\n    # experiment and hold on ice until adding to plate.\n    # Discard any unused portion of the aliquot.\n    operations.store(interactive: true, io: 'output', method: 'boxes')\n  end\n\n  # Get 33 1.5 mL tubes per dried positive control\n  #\n  # @param count [Integer] the number of operations\n  def get_tubes(count:)\n    show do\n      title \"Get new #{TUBE_MICROFUGE}\"\n      check \"Please get #{count * OUTPUT_ITEMS_NUM[:qty]} #{TUBE_MICROFUGE}\"\n    end\n  end\n\n  # Label the tubes so that the same reagents have consecutive IDs\n  # And move the output tubes to the right storage locations\n  # @param operations [OperationList] The list of operations\n  def save_output(ops:)\n    ops.make\n\n    # Declare references to output objects\n    ops.each do |op|\n      op.output(TEMPLATE).item.associate :volume, VOL_SUSPENSION[:qty]\n\n      output_RNA = op.output(TEMPLATE).sample\n      # makes 32 additional aliquots per op\n      (OUTPUT_ITEMS_NUM[:qty] - 1).times do\n        new_aliquot = output_RNA.make_item('Purified RNA in 1.5 mL tube')\n        new_aliquot.associate :volume, VOL_SUSPENSION[:qty]\n        link_output_item(operation: op, sample: output_RNA, item: new_aliquot)\n      end\n    end\n  end\n\n  # Manually link the item to the operation as an output\n  #\n  # @param op [Operation] the operation that creates the items\n  # @param sample [Sample] the sample of the item\n  # @param item [Item] the item that is created\n  def link_output_item(operation:, sample:, item:)\n    fv = FieldValue.new(\n      name: TEMPLATE,\n      child_item_id: item.id,\n      child_sample_id: sample.id,\n      role: 'output',\n      parent_class: 'Operation',\n      parent_id: operation.id,\n      field_type_id: operation.output(TEMPLATE).field_type.id\n    )\n    fv.save\n  end\n\n  # Performs the resuspension protocol for a list of operations\n  # that all use the given lyophilized_RNA input.\n  def suspend_lyophilized_RNA()\n    show do\n      title 'Resuspend Positive Template'\n      warning \"This reagent should be handled with caution in a dedicated \\\n      nucleic acid handling area to prevent possible contamination.\"\n      warning \"Freeze-thaw cycles should be avoided. Maintain on ice when \\\n      thawed.\"\n      check \"Resuspend dried Lyophilized Postive Control RNA in each tube in \\\n      #{qty_display(VOL_WATER)} of nuclease-free water to achieve the \\\n      proper concentration.\"\n    end\n  end\n\n  # Performs the aliquote protocol for a list of operations\n  # that all use the given lyophilized_RNA input.\n  # @param make_aliquots [Item] the lyophilized_RNA\n  # @param operations     [OperationList] the list of operations\n  def make_aliquots(ops:, lyophilized_rna:)\n    last_tube_id = '' # Empty string for storing item id of single use aliquot\n    ops.each do |op|\n      input_rnas = Array.new(OUTPUT_ITEMS_NUM[:qty], lyophilized_rna.id)\n      aliquot_tubes = op.outputs.map{ |output| output.item.id }\n      transfer_table = Table.new\n                            .add_column('Lyophilized RNA', input_rnas)\n                            .add_column('Output RNA Aliquot', aliquot_tubes)\n\n      show do\n        title 'Aliquot Single Used Aliquot Positive Template'\n        check \"Make single use aliquot by transfering \\\n        #{qty_display(VOL_SUSPENSION)} of the diluted postive control into \\\n        individual #{TUBE_MICROFUGE} and label it with the proper item ID.\"\n        check 'Discard the empty input tube'\n        table transfer_table\n      end\n\n      # Discard the input\n      lyophilized_rna.mark_as_deleted\n\n      # Retrieve the last item of the single use aliquot\n      last_tube_id = aliquot_tubes[-1]\n    end\n    last_tube_id\n  end\n\n  # Prepare for plating protocol for a list of operations\n  # that all use the given Purified RNA in 1.5 mL tube output.\n  # @param keep_tubes [Item] Items to be kept on bench for immediate use\n  def prepare_plating(keep_tubes:)\n    show do\n      title 'Preparation of Single Aliquot for Plating'\n      warning \"This reagent should be handled with caution in a dedicated\\\n      nucleic acid handling area to prevent possible contamination.\"\n      warning 'Avoid freeze-thaw cycles. Maintain on ice when thawed.'\n      # Retrieve the last item of the single use aliquot\n      check \"Thaw a single aliquot of diluted positive control #{keep_tubes} \\\n      for each experiment and hold on ice until adding to plate.\"\n      check 'Discard any unused portion of the aliquot.'\n    end\n\n    # Don't store the single aliquot being used during plating\n    keep_tubes.each do |id| Item.find(id).mark_as_deleted end\n  end\nend","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"","timing":null}},{"sample_types":[{"id":6,"name":"Primer/Probe Mix","description":"Primer/Probe Mix for qPCR","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","field_types":[]}],"object_types":[{"id":11,"name":"Lyophilized Primer Mix","description":"Lyophilized Primer Mix","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","unit":"Primer Mix","cost":0.01,"release_method":"return","release_description":"","sample_type_id":6,"image":null,"prefix":"","rows":null,"columns":null,"sample_type_name":"Primer/Probe Mix"},{"id":12,"name":"Primer Mix Aliquot","description":"Primer Mix Aliquot","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","unit":"Primer Mix","cost":0.01,"release_method":"return","release_description":"","sample_type_id":6,"image":null,"prefix":"M20","rows":null,"columns":null,"sample_type_name":"Primer/Probe Mix"}],"operation_type":{"name":"Aliquot Primer/Probe","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Primer/Probe Mix","sample_types":["Primer/Probe Mix"],"object_types":["Lyophilized Primer Mix"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Primer/Probe Mix","sample_types":["Primer/Probe Mix"],"object_types":["Primer Mix Aliquot"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# Aliquot Primer Probe\n# Written By Dany Fu 2020-05-05\n\nneeds 'Diagnostic RT-qPCR/DiagnosticRTqPCRHelper'\n\n# 1) Upon receipt, store dried primers and probes at 2-8C.\n# 2) Precautions: These reagents should only be handled in a clean area and\n# stored at appropriate temperatures (see below) in the dark. Freeze-thaw cycles\n# should be avoided. Maintain cold when thawed.\n# 3) Using aseptic technique, suspend dried reagents in 1.5 mL of nuclease-free\n# water (50X working concentration) and allow to rehydrate for 15 min at room\n# temperature in the dark.\n# 4) Mix gently and aliquot primers/probe in 300 uL volumes into 5 pre-labeled\n# tubes. Store a single aliquot of primers/probe at 2-8oC in the dark. Do not\n# refreeze (stable for up to 4 months). Store remaining aliquots at \u003c= -20oC\n# in a non-frost-free freezer.\nclass Protocol\n  include DiagnosticRTqPCRHelper\n\n  OUTPUT_ITEMS_NUM = { qty: 5, units: TUBE_MICROFUGE }.freeze\n  TIME_REHYDRATE = { qty: 15, units: MINUTES }.freeze\n  VOL_WATER = { qty: 1.5, units: MILLILITERS }.freeze\n  VOL_SUSPENSION = { qty: 300, units: MICROLITERS }.freeze\n\n  COLD_ROOM = 'M4'.freeze\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {}\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {}\n  end\n\n  ########## MAIN ##########\n\n  def main\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n    return {} if operations.errored.any?\n\n    update_operation_params(\n      operations: operations,\n      default_operation_params: default_operation_params\n    )\n\n    get_tubes(count: operations.length)\n    operations.retrieve\n\n    save_output(operations)\n    suspend_primer_mix\n\n    # Group the operations by the input reagent\n    ops_by_input = operations.group_by { |op| op.input(PRIMER_MIX).item }\n    ops_by_input.each do |primer, ops|\n      make_aliquots(ops: ops, primer: primer)\n    end\n\n    operations.store(interactive: true, io: 'output', method: 'boxes')\n  end\n\n  # Get 5 1.5 mL tubes per dried reagent\n  # @param count [Integer] the number of operations currently running\n  def get_tubes(count:)\n    show do\n      title \"Get new #{TUBE_MICROFUGE}\"\n      check \"Please get #{count * OUTPUT_ITEMS_NUM[:qty]} #{TUBE_MICROFUGE}\"\n    end\n  end\n\n  # Create and save multiple output Items per operation\n  # @param operations [OperationList] List of operations\n  def save_output(operations)\n    operations.make\n\n    operations.each do |op|\n      op.output(PRIMER_MIX).item.associate :volume, VOL_SUSPENSION[:qty]\n\n      output_primer = op.output(PRIMER_MIX).sample\n      # makes 4 additional aliquots per op\n      (OUTPUT_ITEMS_NUM[:qty] - 1).times do\n        new_aliquot = output_primer.make_item('Primer Mix Aliquot')\n        new_aliquot.associate :volume, VOL_SUSPENSION[:qty]\n        link_output_item(operation: op, sample: output_primer, item: new_aliquot)\n      end\n    end\n  end\n\n  # Manually link the item to the operation as an output\n  # @param op [Operation] the operation that creates the items\n  # @param sample [Sample] the sample of the item\n  # @param item [Item] the item that is created\n  def link_output_item(operation:, sample:, item:)\n    fv = FieldValue.new(\n      name: PRIMER_MIX,\n      child_item_id: item.id,\n      child_sample_id: sample.id,\n      role: 'output',\n      parent_class: 'Operation',\n      parent_id: operation.id,\n      field_type_id: operation.output(PRIMER_MIX).field_type.id\n    )\n    fv.save\n  end\n\n  # Instructions for suspending dried reagents\n  def suspend_primer_mix\n    show do\n      title 'Suspend Primer Mix'\n      warning 'These reagents should only be handled in a clean area.'\n      warning 'Avoid reeze-thaw cycles. Maintain on ice when thawed.'\n      check \"Using aseptic technique, suspend each dried primer in \\\n             #{qty_display(VOL_WATER)} of nuclease-free water.\"\n      check \"Rehydrate for #{qty_display(TIME_REHYDRATE)} at room temperature \\\n            in the dark.\"\n      timer initial: { minutes: TIME_REHYDRATE[:qty] }\n    end\n  end\n\n  # Make 5 aliquots for each primer\n  # @param operations [OperationList] Array of operations grouped by primer\n  def make_aliquots(ops:, primer:)\n    last_tube_id = '' # keep one of each primer\n    ops.each do |op|\n      input_primers = Array.new(OUTPUT_ITEMS_NUM[:qty], primer.id)\n      aliquot_tubes = op.outputs.map { |output| output.item.id }\n      transfer_table = Table.new\n                            .add_column('Primer Mix ID', input_primers)\n                            .add_column('Destination Tube ID', aliquot_tubes)\n\n      show do\n        title 'Make Aliquots'\n        check 'Label destination tube IDs according to the table.'\n        check \"Mix solution gently and aliquot #{qty_display(VOL_SUSPENSION)} \\\n              of rehydrated primer into each tube according to the table.\"\n        table transfer_table\n      end\n\n      primer.mark_as_deleted # discard the input\n      last_tube_id = aliquot_tubes[-1]\n    end\n\n    # One aliquot of each primer mix should be stored in the cold room instead\n    # of freezer. However, this code doesn't actually work as one ObjectType\n    # can only be associated with one location.\n    # Leaving this here for completeness.\n    last_tube = Item.find(last_tube_id)\n    last_tube.move(COLD_ROOM)\n    last_tube.store\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# frozen_string_literal: true\n\nclass ProtocolTest \u003c ProtocolTestBase\n  def setup\n    add_random_operations(1)\n  end\n\n  def analyze\n    log('Hello from Nemo')\n    assert_equal(@backtrace.last[:operation], 'complete')\n  end\nend","timing":null}},{"sample_types":[{"id":1,"name":"Diagnostic Samplle","description":"Incoming sample for testing","created_at":"2020-07-07T09:04:43.000-07:00","updated_at":"2020-07-07T10:33:59.000-07:00","field_types":[]}],"object_types":[{"id":3,"name":"Patient Swab","description":"Nasopharyngeal Swab","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T09:04:43.000-07:00","updated_at":"2020-07-07T09:04:43.000-07:00","unit":"each","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":null,"prefix":"M80","rows":null,"columns":null,"sample_type_name":"Diagnostic Samplle"},{"id":16,"name":"Purified RNA in 1.5 ml Tube","description":"Purified RNA in a 15 ml Eppendorf tube","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T10:36:36.000-07:00","updated_at":"2020-07-07T10:36:36.000-07:00","unit":"Diagnostic Samplle","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":"","prefix":"M80","rows":null,"columns":null,"sample_type_name":"Diagnostic Samplle"}],"operation_type":{"name":"Extract RNA","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Specimen","sample_types":["Diagnostic Samplle"],"object_types":["Patient Swab"],"part":false,"array":false,"routing":"S","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Specimen","sample_types":["Diagnostic Samplle"],"object_types":["Purified RNA in 1.5 ml Tube"],"part":false,"array":false,"routing":"S","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# frozen_string_literal: true\n\nneeds 'Diagnostic RT-qPCR/RNAExtractionHelper'\n\n# Extract RNA Protocol\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass Protocol\n  include RNAExtractionHelper\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {\n      rna_extraction_kit: TestRNAExtractionKit::NAME\n    }\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {\n      sample_volume: { qty: 300, units: MICROLITERS }\n    }\n  end\n\n  ########## MAIN ##########\n\n  def main\n    setup_test_options(operations: operations) if debug\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n    return {} if operations.errored.any?\n\n    operations.retrieve.make\n    \n    set_kit(name: @job_params[:rna_extraction_kit])\n    \n    \n    sample_volumes = operations.map { |op| sample_volume(op) }\n    if sample_volumes.uniq.length == 1\n      run_rna_extraction_kit(\n        operations: operations,\n        sample_volume: sample_volumes.first\n      )\n    else\n      run_rna_extraction_kit(\n        operations: operations,\n        #use_operations: true\n      )\n    end\n\n    operations.store\n\n    {}\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# frozen_string_literal: true\n\nclass ProtocolTest \u003c ProtocolTestBase\n  def setup\n    add_random_operations(1)\n  end\n\n  def analyze\n    log('Hello from Nemo')\n    assert_equal(@backtrace.last[:operation], 'complete')\n  end\nend\n","timing":null}},{"sample_types":[],"object_types":[],"operation_type":{"name":"Extract RNA HTP","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Specimen","sample_types":[],"object_types":[],"part":false,"array":false,"routing":"S","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Specimen","sample_types":[],"object_types":[],"part":false,"array":false,"routing":"T","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# frozen_string_literal: true\n\nneeds 'Diagnostic RT-qPCR/RNAExtractionHelper'\n\n# Extract RNA Protocol\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass Protocol\n  include RNAExtractionHelper\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {\n      rna_extraction_kit: TestRNAExtractionKit::NAME\n    }\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {\n      sample_volume: { qty: 300, units: MICROLITERS }\n    }\n  end\n\n  ########## MAIN ##########\n\n  def main\n    setup_test_options(operations: operations) if debug\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n    return {} if operations.errored.any?\n\n    operations.retrieve.make\n\n    set_kit(name: @job_params[:rna_extraction_kit])\n\n    sample_volumes = operations.map { |op| sample_volume(op) }\n    if sample_volumes.uniq.length == 1\n      run_rna_extraction_kit(\n        operations: operations,\n        sample_volume: sample_volumes.first\n      )\n    else\n      run_rna_extraction_kit(\n        operations: operations,\n        use_operations: true\n      )\n    end\n\n    operations.store\n\n    {}\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# test","timing":null}},{"sample_types":[{"id":7,"name":"qPCR Reaction","description":"qPCR Reaction","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","field_types":[]},{"id":6,"name":"Primer/Probe Mix","description":"Primer/Probe Mix for qPCR","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","field_types":[]}],"object_types":[{"id":8,"name":"96-well qPCR Plate","description":"96-well qPCR Reaction","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","unit":"qPCR Reaction","cost":0.01,"release_method":"return","release_description":"","sample_type_id":7,"image":null,"prefix":"","rows":8,"columns":12,"sample_type_name":"qPCR Reaction"},{"id":12,"name":"Primer Mix Aliquot","description":"Primer Mix Aliquot","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","unit":"Primer Mix","cost":0.01,"release_method":"return","release_description":"","sample_type_id":6,"image":null,"prefix":"M20","rows":null,"columns":null,"sample_type_name":"Primer/Probe Mix"}],"operation_type":{"name":"Prepare Master Mix","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"output","name":"PCR Plate","sample_types":["qPCR Reaction"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"input","name":"Primer/Probe Mix","sample_types":["Primer/Probe Mix"],"object_types":["Primer Mix Aliquot"],"part":false,"array":true,"routing":"M","preferred_operation_type_id":5,"preferred_field_type_id":14,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Standard Libs/PlanParams'\nneeds 'Standard Libs/CommonInputOutputNames'\nneeds 'Standard Libs/Debug'\nneeds 'Standard Libs/Pipettors'\nneeds 'Standard Libs/LabwareNames'\nneeds 'Collection Management/CollectionActions'\nneeds 'Collection Management/CollectionDisplay'\nneeds 'Microtiter Plates/MicrotiterPlates'\nneeds 'PCR Libs/PCRComposition'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\n\n# Protocol for setting up a master mix plate for RT-qPCR\n# @note Instructions adapted from the CDC COVID-19 detection protocol\n#   https://www.fda.gov/media/134922/download\n#\n# 1) In the reagent set-up room clean hood, place rRT-PCR buffer, enzyme,\n#     and primer/probes on ice or cold-block. Keep cold during preparation\n#     and use.\n#\n# 2) Mix buffer, enzyme, and primer/probes by inversion 5 times.\n#\n# 3) Centrifuge reagents and primers/probes for 5 seconds to collect\n#     contents at the bottom of the tube, and then place the tube in\n#     a cold rack.\n#\n# 4) Label one 1.5 mL microcentrifuge tube for each primer/probe set.\n#\n# 5) Determine the number of reactions (N) to set up per assay.\n#   It is necessary to make excess reaction mix for the NTC, nCoVPC,\n#   HSC (if included in the RT-PCR run), and RP reactions and for pipetting\n#   error. Use the following guide to determine N:\n#     - If number of samples (n) including controls equals 1 through 14,\n#       then N = n + 1\n#     - If number of samples (n) including controls is 15 or greater,\n#       then N = n + 2\n#\n# 7) For each primer/probe set, calculate the amount of each reagent\n#   to be added for each reaction mixture (N = # of reactions).\n#\n# 8) Dispense reagents into each respective labeled 1.5 mL microcentrifuge\n#   tube. After addition of the reagents, mix reaction mixtures by\n#   pipetting up and down. Do not vortex.\n#\n# 9) Centrifuge for 5 seconds to collect contents at the bottom of\n#   the tube, and then place the tube in a cold rack.\n#\n# 10) Set up reaction strip tubes or plates in a 96-well cooler rack.\n#\n# 11) Dispense 15 uL of each master mix into the appropriate wells going\n#   across the row\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass Protocol\n  # Standard Libs\n  include PlanParams\n  include CommonInputOutputNames\n  include Debug\n  include Pipettors\n  include LabwareNames\n\n  # Collection Management\n  include CollectionActions\n  include CollectionDisplay\n\n  # Diagnostic RT-qPCR\n  include DataAssociationKeys\n\n  WATER = 'Molecular Grade Water'\n  RNA_FREE_WORKSPACE = 'reagent set-up room'\n  PLATE = 'PCR Plate'\n  PRIMER_MIX = 'Primer/Probe Mix'\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {}\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {\n      number_of_reactions: 24,\n      group_size: 24,\n      program_name: 'CDC_TaqPath_CG',\n      layout_method: 'cdc_primer_layout'\n    }\n  end\n\n  ########## MAIN ##########\n\n  def main\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n    return {} if operations.errored.any?\n\n    provision_plates(\n      operations: operations,\n      object_type: '96-well qPCR Plate'\n    )\n\n    prepare_materials(operations: operations)\n\n    assemble_master_mix_plates(operations: operations)\n\n    operations.store\n\n    inspect_data_associations(operation: operations.first) if debug\n\n    {}\n  end\n\n  # Creates and assigns an output collection for each operation, and fills it\n  #   with the output sample according to the provided PlateLayoutGenerator\n  #   method\n  # @note In debug mode, displays the matrix of each collection\n  #\n  # @param operations [OperationList]\n  # @param object_type [String] the ObjectType of the collection to be made\n  # @return void\n  def provision_plates(operations:, object_type:)\n    operations.each do |op|\n      collection = make_new_plate(object_type, label_plate: true)\n      op.output(PLATE).set(collection: collection)\n\n      set_parts(\n        collection: collection,\n        group_size: op.temporary[:options][:group_size],\n        method: op.temporary[:options][:layout_method],\n        sample: op.output(PLATE).sample\n      )\n\n      inspect op.output(PLATE).collection.matrix if debug\n    end\n  end\n\n  # Fills a collection with the provided sample according to the provided\n  #   PlateLayoutGenerator method\n  #\n  # @param collection [Collection]\n  # @param group_size [Fixnum]\n  # @param method [String] a PlateLayoutGenerator method\n  # @param sample [Sample] the Sample to add to the collection\n  # @return void\n  def set_parts(collection:, group_size:, method:, sample:)\n    layout_generator = PlateLayoutGeneratorFactory.build(\n      group_size: group_size,\n      method: method\n    )\n\n    loop do\n      index = layout_generator.next\n      break unless index.present?\n      collection.set(index[0], index[1], sample)\n    end\n  end\n\n  # Prepare workspace and materials\n  #\n  # @todo Make this handle master mix or enzyme with separate buffer dynamically\n  # @param operations [OperationList]\n  def prepare_materials(operations:)\n    show_prepare_workspace\n    operations.retrieve\n    show_mix_and_spin_reagents\n  end\n\n  # Assembles a master mix plate for each operation\n  #\n  # @param operations [OperationList]\n  # @return void\n  def assemble_master_mix_plates(operations:)\n    operations.each { |op| assemble_master_mix_plate(operation: op) }\n  end\n\n  # Assembles a master mix plate for an operation\n  #\n  # @param operation [Operation]\n  # @return void\n  def assemble_master_mix_plate(operation:)\n    primer_mixes = operation.input_array(PRIMER_MIX).map(\u0026:item)\n    output_collection = operation.output(PLATE).collection\n\n    show_label_mmix_tubes(labels: primer_mixes.map { |pm| pm.sample.name })\n\n    group_size = operation.temporary[:options][:group_size]\n    program_name = operation.temporary[:options][:program_name]\n    composition = PCRCompositionFactory.build(\n      program_name: program_name\n    )\n    \n    \n    output_collection.associate(COMPOSITION_NAME_KEY, program_name)\n    output_collection.associate(PRIMER_GROUP_SIZE_KEY, group_size)\n\n    master_mixes = make_master_mixes(\n      primer_mixes: primer_mixes,\n      composition: composition,\n      sample_number: sample_number_with_excess(sample_number: group_size)\n    )\n\n    microtiter_plate = MicrotiterPlateFactory.build(\n      collection: output_collection,\n      group_size: group_size,\n      method: :cdc_primer_layout\n    )\n    master_mixes.each do |master_mix|\n      pipet_master_mix(\n        master_mix: master_mix,\n        volume: composition.sum_added_components,\n        microtiter_plate: microtiter_plate\n      )\n    end\n  end\n\n  # Makes large volume master mixes to be distributed among wells\n  #\n  # @param primer_mixes [Array\u003cItem\u003e]\n  # @param composition [PCRComposition]\n  # @param sample_number [Fixnum] the number samples for each primer\n  # @return [Array\u003cHash\u003e] a data structure that documents the provenance of the\n  #   master mixes\n  def make_master_mixes(primer_mixes:, composition:, sample_number:)\n    show_make_master_mixes(\n      primer_mixes: primer_mixes,\n      composition: composition,\n      sample_number: sample_number\n    )\n\n    build_master_mix_data(\n      primer_mixes: primer_mixes,\n      composition: composition\n    )\n  end\n\n  # Pipet the master mixes to individual wells\n  #\n  # @todo make volume a qty, units Hash\n  # @param master_mix [Hash] a data structure documenting the provenance of the\n  #   master mix\n  # @param volume [Numeric]\n  # @param microtiter_plate [MicrotiterPlate]\n  # @return void\n  def pipet_master_mix(master_mix:, volume:, microtiter_plate:)\n    layout_group = microtiter_plate.associate_next_empty_group(\n      key: MASTER_MIX_KEY,\n      data: master_mix[:data]\n    )\n\n    show_pipet_mmix(\n      primer_mix_name: master_mix[:primer_mix].sample.name,\n      volume: volume,\n      collection: microtiter_plate.collection,\n      layout_group: layout_group\n    )\n  end\n\n  ########## DATA METHODS ##########\n\n  # Compute the number of 'extra' master mixes to make to account for\n  #   pipetting error\n  #\n  # @param sample_number [Fixnum]\n  # @return [Fixnum]\n  def sample_number_with_excess(sample_number:)\n    sample_number \u003c 15 ? sample_number + 1 : sample_number + 2\n  end\n\n  # Build the data structure that documents the provenance of the\n  #   master mixes\n  #\n  # @param primer_mixes [Array\u003cItem\u003e]\n  # @param composition [PCRComposition]\n  # @return [Array\u003cHash\u003e] a data structure that documents the provenance of the\n  #   master mixes\n  def build_master_mix_data(primer_mixes:, composition:)\n    master_mixes = []\n    primer_mixes.each do |primer_mix|\n      mm = master_mix_data(primer_mix: primer_mix, composition: composition)\n      master_mixes.append(mm)\n    end\n    master_mixes\n  end\n\n  # Build the data structure that documents the provenance of a\n  #   master mix\n  #\n  # @param primer_mix [Item]\n  # @param composition [PCRComposition]\n  # @return [Hash] a data structure that documents the provenance of a\n  #   master mix\n  def master_mix_data(primer_mix:, composition:)\n    {\n      primer_mix: primer_mix,\n      data: {\n        PRIMER_PROBE_MIX_KEY =\u003e {\n          item_id: primer_mix.id,\n          volume: composition.primer_probe_mix.qty_display\n        },\n        MASTER_MIX_STOCK_KEY =\u003e {\n          sample_name: composition.master_mix.display_name,\n          volume: composition.master_mix.qty_display\n        }\n      }\n    }\n  end\n\n  ########## SHOW METHODS ##########\n\n  # Instruct technician to do everything necessary to prepare the workspace\n  #\n  # @return [void]\n  def show_prepare_workspace\n    show do\n      title 'Prepare workspace'\n\n      note \"All tasks in this protocol occur in the #{RNA_FREE_WORKSPACE}.\"\n      note 'As you retrieve reagents, place them on ice or in a cold-block.'\n    end\n  end\n\n  # Instruct technician to mix the incoming reagents and spin down the tubes\n  #\n  # @return [void]\n  def show_mix_and_spin_reagents\n    show do\n      title 'Mix and spin down reagents'\n\n      note 'Mix buffer, enzyme, and primer/probes by inversion 5 times.'\n      note 'Centrifuge reagents and primers/probes for 5 seconds to collect' \\\n        ' contents at the bottom of the tube.'\n      note 'Place the tubes on ice or in a cold-block.'\n    end\n  end\n\n  # Instruct technician to label the tubes that will contain the master mixes\n  #\n  # @param labels [Array\u003cString\u003e]\n  # @return [void]\n  def show_label_mmix_tubes(labels:)\n    n = labels.length\n    labels = labels.map { |label| \"\u003cb\u003e#{label}\u003c/b\u003e\" }\n    show do\n      title 'Label master mix tubes'\n\n      note \"Take out #{n} #{TUBE_MICROFUGE.pluralize(n)}\"\n      note \"Write #{labels.to_sentence} on the tops of each tube\"\n    end\n  end\n\n  # Instruct technician to make large volume master mixes to be\n  #   distributed among wells\n  #\n  # @param primer_mixes [Array\u003cItem\u003e]\n  # @param composition [PCRComposition]\n  # @param sample_number [Fixnum]\n  # @return [void]\n  def show_make_master_mixes(primer_mixes:, composition:, sample_number:)\n    show do\n      title 'Pipet master mix components'\n\n      note 'Pipet the following components into each labeled master mix tube'\n      table master_mix_table(\n        composition: composition,\n        sample_number: sample_number\n      )\n      separator\n\n      note 'Pipet the primer/probe mixes into each corresponding' \\\n        ' master mix tube'\n      table primer_probe_table(\n        primer_mixes: primer_mixes,\n        composition: composition,\n        sample_number: sample_number\n      )\n    end\n  end\n\n  # Instruct technician to pipet a master mix into the plate\n  #\n  # @param primer_mix_name [String]\n  # @param volume [Numeric]\n  # @param collection [Collection]\n  # @param layout_group [Array\u003cFixnum\u003e]\n  # @return [void]\n  def show_pipet_mmix(primer_mix_name:, volume:, collection:, layout_group:)\n    show do\n      title \"Pipet #{primer_mix_name} master mix into plate\"\n\n      note \"Pipet #{volume} #{MICROLITERS} of #{primer_mix_name}\" \\\n        \" master mix into the plate #{collection}\"\n      table highlight_collection_rc(collection, layout_group, check: false)\n    end\n  end\n\n  ########## TABLE METHODS ##########\n\n  # Build table for volumes of master mix components\n  #\n  # @param composition [PCRComposition]\n  # @param sample_number [Fixnum]\n  # @return [Array\u003cArray\u003e] a 2D array formatted for the `table` method in Krill\n  def master_mix_table(composition:, sample_number:)\n    header = [\n      'Component',\n      composition.master_mix.display_name,\n      composition.water.display_name\n    ]\n    row = [\n      \"Volume (#{MICROLITERS})\",\n      composition.master_mix.add_in_table(sample_number),\n      composition.water.add_in_table(sample_number)\n    ]\n    [header, row].transpose\n  end\n\n  # Build table for volumes of master mix components\n  #\n  # @param composition [PCRComposition]\n  # @param sample_number [Fixnum]\n  # @return [Array\u003cArray\u003e] a 2D array formatted for the `table` method in Krill\n  def primer_probe_table(primer_mixes:, composition:, sample_number:)\n    table = [[\n      composition.primer_probe_mix.display_name,\n      'Item',\n      \"Volume (#{MICROLITERS})\"\n    ]]\n    primer_mixes.each do |primer_mix|\n      row = [\n        primer_mix.sample.name,\n        primer_mix.to_s,\n        composition.primer_probe_mix.add_in_table(sample_number)\n      ]\n      table.append(row)\n    end\n    table\n  end\n\n  def inspect_data_associations(operation:)\n    collection = operation.output(PLATE).collection\n    [[0, 0], [0, 3], [0, 8]].each do |r, c|\n      part = collection.part(r, c)\n      inspect part, \"part at #{[r, c]}\"\n      inspect part.associations, \"data at #{[r, c]}\"\n    end\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# frozen_string_literal: true\n\nclass ProtocolTest \u003c ProtocolTestBase\n  def setup\n    add_random_operations(1)\n\n  #   mm = Sample.find_by_name('TaqPath 1-Step RT-qPCR Master Mix')\n  #   p1 = Sample.find_by_name('2019-nCoV_N1')\n  #   p2 = Sample.find_by_name('2019-nCoV_N2')\n  #   p3 = Sample.find_by_name('RNase P')\n\n  #   add_operation\n  #     .with_property(\"Options\", '{ \"magic_number\": 24, \"foo\": \"baz\" }')\n  #     .with_input('Enzyme Master Mix', mm)\n  #     .with_input('Primer/Probe Mix', p1)\n  #     .with_input('Primer/Probe Mix', p2)\n  #     .with_input('Primer/Probe Mix', p3)\n  end\n\n  def analyze\n    log('Hello from Nemo')\n    assert_equal(@backtrace.last[:operation], 'complete')\n  end\nend","timing":null}},{"sample_types":[{"id":1,"name":"Diagnostic Samplle","description":"Incoming sample for testing","created_at":"2020-07-07T09:04:43.000-07:00","updated_at":"2020-07-07T10:33:59.000-07:00","field_types":[]},{"id":7,"name":"qPCR Reaction","description":"qPCR Reaction","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","field_types":[]}],"object_types":[{"id":16,"name":"Purified RNA in 1.5 ml Tube","description":"Purified RNA in a 15 ml Eppendorf tube","min":0,"max":1,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T10:36:36.000-07:00","updated_at":"2020-07-07T10:36:36.000-07:00","unit":"Diagnostic Samplle","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":"","prefix":"M80","rows":null,"columns":null,"sample_type_name":"Diagnostic Samplle"},{"id":8,"name":"96-well qPCR Plate","description":"96-well qPCR Reaction","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","unit":"qPCR Reaction","cost":0.01,"release_method":"return","release_description":"","sample_type_id":7,"image":null,"prefix":"","rows":8,"columns":12,"sample_type_name":"qPCR Reaction"}],"operation_type":{"name":"Prepare RT-qPCR Plate","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Template","sample_types":["Diagnostic Samplle"],"object_types":["Purified RNA in 1.5 ml Tube"],"part":false,"array":true,"routing":"T","preferred_operation_type_id":null,"preferred_field_type_id":17,"choices":null},{"ftype":"sample","role":"input","name":"PCR Plate","sample_types":["qPCR Reaction"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":3,"preferred_field_type_id":8,"choices":null},{"ftype":"sample","role":"output","name":"PCR Plate","sample_types":["qPCR Reaction"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Diagnostic RT-qPCR/DiagnosticRTqPCRHelper'\nneeds 'Diagnostic RT-qPCR/DiagnosticRTqPCRDebug'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\nneeds 'PCR Libs/PCRComposition'\nneeds 'Microtiter Plates/MicrotiterPlates'\nneeds 'Collection Management/CollectionTransfer'\n\n# Protocol for setting up a plate with extracted RNA samples\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n# @author Cannon Mallory \u003cmalloc3@uw.edu\u003e\nclass Protocol\n  include DiagnosticRTqPCRHelper\n  include DiagnosticRTqPCRDebug\n  include MicrotiterPlates\n  include CollectionTransfer\n  include DataAssociationKeys\n\n  METHOD = :cdc_sample_layout\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {\n      max_inputs: 24\n    }\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {\n      negative_template_control: nil,\n      negative_template_location: nil,\n      positive_template_control: 'nCoVPC',\n      positive_template_location: [0, 11],\n      group_size: 3\n    }\n  end\n\n  def main\n    #========= Setup Job ==========#\n    setup_test(operations) if debug\n    @job_params = update_all_params(\n      operations: operations,\n      default_job_params: default_job_params,\n      default_operation_params: default_operation_params\n    )\n\n    #========= Validation =========#\n    validate(operations: operations)\n    return {} if operations.errored.any?\n\n    #====== General Warnings =====#\n    rnase_warning\n    safety_warning\n\n    operations.retrieve.make\n\n    #====== Core Operation ======#\n    operations.each do |op|\n      op.pass(PLATE)\n      output_collection = op.output(PLATE).collection\n      group_size = op.temporary[:options][:group_size]\n      output_collection.associate(SAMPLE_GROUP_SIZE_KEY, group_size)\n      program_name = output_collection.get(COMPOSITION_NAME_KEY)\n\n      microtiter_plate = MicrotiterPlateFactory.build(\n        collection: output_collection,\n        group_size: group_size,\n        method: METHOD\n      )\n\n      composition = PCRCompositionFactory.build(\n        program_name: program_name\n      )\n      volume = { qty: composition.template.qty,\n                 units: composition.template.units }\n\n      remaining_inputs = add_control_samples(\n        operation_inputs: op.input_array(TEMPLATE),\n        microtiter_plate: microtiter_plate,\n        volume: volume,\n        operation_parameters: op.temporary[:options]\n      )\n\n      add_diagnostic_samples(\n        operation_inputs: remaining_inputs,\n        microtiter_plate: microtiter_plate,\n        volume: volume\n      )\n\n      seal_plate(output_collection)\n      show_result(collection: output_collection) if debug\n    end\n\n    operations.store\n\n    {}\n  end\n\n  # Provides instructions and handling for addition of control\n  # samples.  Returns all inputs that are NOT control inputs\n  #\n  # @param operation_inputs [Array\u003citem\u003e]\n  # @param collection [Collection]\n  # @param layout_generator [LayoutGenerator]\n  # @param volume [{aty: int, unit: string}]\n  # @return operation_inputs [Array\u003citem\u003e]\n  def add_control_samples(operation_inputs:, microtiter_plate:,\n                          volume:, operation_parameters:)\n    %w[negative_template positive_template].each do |stub|\n      name = operation_parameters[\"#{stub}_control\".to_sym]\n      loc = operation_parameters[\"#{stub}_location\".to_sym]\n\n      next unless name.present? \u0026\u0026 loc.present?\n\n      control_inputs, operation_inputs = operation_inputs.partition do |fv|\n        fv.sample.name == name\n      end\n\n      add_samples(\n        operation_inputs: control_inputs,\n        microtiter_plate: microtiter_plate,\n        volume: volume,\n        column: loc[1]\n      )\n\n      # negative control samples need to be covered after addition\n      next unless stub.include?('negative')\n\n      seal_plate(collection, rc_list: get_rna_samples(collection))\n    end\n    operation_inputs\n  end\n\n  # Provides instructions to add diagnostic samples to collection\n  #\n  # @param operation_inputs [Array\u003citems\u003e]\n  # @param collection [Collection]\n  # @param layout_generator [LayoutGenerator]\n  # @param volume [{aty: int, unit: string}]\n  def add_diagnostic_samples(operation_inputs:, microtiter_plate:,\n                            volume:)\n    add_samples(\n      operation_inputs: operation_inputs,\n      microtiter_plate: microtiter_plate,\n      volume: volume\n    )\n  end\n\n  # validates operations and ensures that they are formatted as expected\n  #\n  # @param operations [OperationList]\n  def validate(operations:)\n    operations.each do |op|\n      if op.input_array(TEMPLATE).length \u003e @job_params[:max_inputs]\n        raise IncompatibleInputsError, \"Too many inputs for Operation #{op.id}\"\n      end\n    end\n  rescue IncompatibleInputsError =\u003e e\n    error_operations(operations: operations, err: e)\n  end\n\n  # Say you're quitting due to an error and error all the operations\n  #\n  def error_operations(operations:, err:)\n    show do\n      title 'Incompatible Inputs Detected'\n      warning err.message\n    end\n\n    operations.each { |op| op.error(:incompatible_inputs, err.message) }\n  end\n\n  class IncompatibleInputsError \u003c ProtocolError; end\n  class NoAvailableWells \u003c ProtocolError; end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"class ProtocolTest \u003c ProtocolTestBase\n    def setup\n      add_random_operations(1)\n    end\n  \n    def analyze\n      log('Hello from Nemo')\n      assert_equal(@backtrace.last[:operation], 'complete')\n    end\n  end","timing":null}},{"sample_types":[{"id":7,"name":"qPCR Reaction","description":"qPCR Reaction","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","field_types":[]}],"object_types":[{"id":8,"name":"96-well qPCR Plate","description":"96-well qPCR Reaction","min":0,"max":1,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-07-07T09:05:20.000-07:00","updated_at":"2020-07-07T09:05:20.000-07:00","unit":"qPCR Reaction","cost":0.01,"release_method":"return","release_description":"","sample_type_id":7,"image":null,"prefix":"","rows":8,"columns":12,"sample_type_name":"qPCR Reaction"}],"operation_type":{"name":"Run qPCR","category":"Diagnostic RT-qPCR","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"qPCR Reactions","sample_types":["qPCR Reaction"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"json","role":"input","name":"Options","sample_types":[],"object_types":[],"part":false,"array":false,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"qPCR Reactions","sample_types":["qPCR Reaction"],"object_types":["96-well qPCR Plate"],"part":false,"array":false,"routing":"P","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"# frozen_string_literal: true\n\nneeds 'PCR Libs/PCRComposition'\nneeds 'PCR Libs/PCRProgram'\nneeds 'Thermocyclers/Thermocyclers'\nneeds 'Standard Libs/PlanParams'\nneeds 'Standard Libs/Debug'\n\n# Protocol for loading samples into a qPCR thermocycler and running it\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n# @todo Decide whether this is actually qPCR specific\nclass Protocol\n  include ThermocyclerHelper\n  include PlanParams\n  include Debug\n\n  INPUT_REACTIONS = 'qPCR Reactions'\n\n  ########## DEFAULT PARAMS ##########\n\n  # Default parameters that are applied equally to all operations.\n  #   Can be overridden by:\n  #   * Associating a JSON-formatted list of key, value pairs to the `Plan`.\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_job_params\n    {\n      thermocycler_model: TestThermocycler::MODEL,\n      program_name: 'CDC_TaqPath_CG',\n      qpcr: true\n    }\n  end\n\n  # Default parameters that are applied to individual operations.\n  #   Can be overridden by:\n  #   * Adding a JSON-formatted list of key, value pairs to an `Operation`\n  #     input of type JSON and named `Options`.\n  #\n  def default_operation_params\n    {}\n  end\n\n  ########## MAIN ##########\n\n  def main\n    setup_test_options(operations: operations) if debug\n\n    @job_params = update_job_params(\n      operations: operations,\n      default_job_params: default_job_params\n    )\n    return {} if operations.errored.any?\n\n    operations.retrieve.make\n\n    composition = PCRCompositionFactory.build(\n      program_name: @job_params[:program_name]\n    )\n    program = PCRProgramFactory.build(\n      program_name: @job_params[:program_name],\n      volume: composition.volume\n    )\n    thermocycler = ThermocyclerFactory.build(\n      model: @job_params[:thermocycler_model]\n    )\n\n    set_up_program(\n      thermocycler: thermocycler,\n      program: program,\n      composition: composition,\n      qpcr: @job_params[:qpcr]\n    )\n\n    load_plate_and_start_run(\n      thermocycler: thermocycler,\n      items: operations.map { |op| op.input(INPUT_REACTIONS).item },\n      experiment_filename: experiment_filename\n    )\n\n    export_measurements(thermocycler: thermocycler)\n\n    operations.store\n\n    {}\n  end\n\n  ########## NAMING METHODS ##########\n\n  # Constructs a name for the experiment file.\n  #\n  # @return [String]\n  def experiment_filename\n    date = DateTime.now.strftime('%Y-%m-%d')\n    \"#{date}_Job_#{job.id}\"\n  end\n\n  # Gets the currently active `Job`\n  #\n  # @return [Job]\n  def job\n    operation_ids = operations.map(\u0026:id)\n    ja_ids = JobAssociation.where(operation_id: operation_ids).map(\u0026:job_id).uniq\n    jobs = Job.find(ja_ids).select(\u0026:active?)\n    raise ProtocolError, 'Cannot resolve the current Job' if jobs.length \u003e 1\n\n    jobs.last\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"# frozen_string_literal: true\n\nclass ProtocolTest \u003c ProtocolTestBase\n  def setup\n    add_random_operations(1)\n    # [1..3].each do |i|\n    #   s = Sample.find_by_name(\"Test qPCR Reaction #{i}\")\n    #   add_operation\n    #     .with_input('qPCR Reactions', s)\n    #     .with_property('Options', '{\"thermocycler_model\": \"BioRad CFX96\", \"program_name\": \"CDC_qScript_XLT_ToughMix\"}')\n    #     .with_output('qPCR Reactions', s)\n    # end\n  end\n\n  def analyze\n    log('Hello from Nemo')\n    assert_equal(@backtrace.last[:operation], 'complete')\n  end\nend\n","timing":null}},{"library":{"name":"DataAssociationKeys","category":"Diagnostic RT-qPCR","code_source":"# frozen_string_literal: true\n\nmodule DataAssociationKeys\n  PRIMER_GROUP_SIZE_KEY = 'primer_group_size'\n  COMPOSITION_NAME_KEY = 'composition_name'\n  MASTER_MIX_KEY = 'master_mix'\n  MASTER_MIX_STOCK_KEY = 'master_mix_stock'\n  PRIMER_PROBE_MIX_KEY = 'primer_probe_mix'\n  TEMPLATE_KEY = 'template'\n  SAMPLE_GROUP_SIZE_KEY = 'sample_group_size'\nend\n"}},{"library":{"name":"DiagnosticRTqPCRDebug","category":"Diagnostic RT-qPCR","code_source":"# typed: false\n# frozen_string_literal: true\nneeds 'Collection Management/CollectionTransfer'\nneeds 'Diagnostic RT-qPCR/DiagnosticRTqPCRHelper'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\n\nmodule DiagnosticRTqPCRDebug\n  include CollectionTransfer\n  include DiagnosticRTqPCRHelper\n  include DataAssociationKeys\n\n  VERBOSE = false\n\n  def debug_parameters\n    {\n      group_size: 3,\n      program_name: 'CDC_TaqPath_CG',\n      debug_primer: [5, 8, 9], # rp, n1, n2,\n      debug_template: 'template',\n      debug_items: [48,\n                    42,\n                    42,\n                    42,\n                    42,\n                    42,\n                    42,\n                    42]\n    }\n  end\n\n  def setup_test(operations)\n    operations.each do |op|\n      setup_test_plate(collection: op.input('PCR Plate').collection)\n      op.set_input('Template', generate_samples(debug_parameters[:debug_items]))\n    end\n  end\n\n  # Populate test plate with qPCR Reactions and one no template control (NTC)\n  #\n  def setup_test_plate(collection:)\n    verbose = false\n    key = TEMPLATE_KEY\n    collection.associate(COMPOSITION_NAME_KEY, debug_parameters[:program_name])\n    collection.associate(SAMPLE_GROUP_SIZE_KEY, debug_parameters[:group_size])\n    qpcr_reaction = Sample.find_by_name('Generic qPCR Reaction')\n    ntc_item = Item.find(48)\n    layout_generator = PlateLayoutGeneratorFactory.build(\n      group_size: debug_parameters[:group_size],\n      method: :cdc_sample_layout\n    )\n    i = 0\n    loop do\n      layout_group = layout_generator.next_group\n      break unless layout_group.present?\n      layout_group.each do |r, c|\n        collection.set(r, c, qpcr_reaction)\n        next if i.positive?\n        part = collection.part(r, c)\n        inspect part, \"part at #{[r, c]}\" if verbose\n        part.associate(key, ntc_item)\n        inspect part.associations, \"#{key} at #{[r, c]}\" if verbose\n      end\n      i += 1\n    end\n    show_result(collection: collection) if verbose\n    inspect collection.parts.to_s if verbose\n  end\n\n  def generate_samples(debug_item_ids)\n    debug_items = []\n    debug_item_ids.each do |id|\n      debug_items.push(Item.find(id))\n    end\n    debug_items\n  end\n\n  def show_result(collection:)\n    show do\n      table highlight_non_empty(collection)\n    end\n  end\n\nend\n"}},{"library":{"name":"DiagnosticRTqPCRHelper","category":"Diagnostic RT-qPCR","code_source":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Standard Libs/PlanParams'\nneeds 'Standard Libs/CommonInputOutputNames'\nneeds 'Standard Libs/Debug'\nneeds 'Standard Libs/Pipettors'\nneeds 'Standard Libs/LabwareNames'\nneeds 'Collection Management/CollectionActions'\nneeds 'Collection Management/CollectionDisplay'\nneeds 'Collection Management/CollectionTransfer'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\n\n# Module for elements that are common throughout Diagnostic RT qPCR\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nmodule DiagnosticRTqPCRHelper\n  # Standard Libs\n  include Units\n  include PlanParams\n  include CommonInputOutputNames\n  include Debug\n  include Pipettors\n  include LabwareNames\n\n  # Collection Management\n  include CollectionActions\n  include CollectionDisplay\n  include CollectionTransfer\n\n  #Diagnostic RT-qPCR\n  include DataAssociationKeys\n\n  WATER = 'Molecular Grade Water'\n  RNA_FREE_WORKSPACE = 'reagent set-up room'\n  PLATE = 'PCR Plate'\n  PRIMER_MIX = 'Primer/Probe Mix'\n  TEMPLATE = 'Template'\n\n  def rnase_warning\n    show do\n      title 'RNase degrades RNA'\n      note 'RNA is prone to degradation by RNase present in our eyes, skin, and breath.'\n      note 'Avoid opening tubes outside the Biosafety Cabinet (BSC).'\n      bullet 'Change gloves whenever you suspect potential RNAse contamination'\n    end\n  end\n\n  def safety_warning\n    show do\n      title 'Review Safety Warnings'\n      note '\u003cb\u003eAlways\u003c/b\u003e pay attention to orange warning blocks throughout the protocol.'\n      warning '\u003cb\u003eINFECTIOUS MATERIALS\u003c/b\u003e'\n      note 'You will be working with infectious materials.'\n      note 'Do \u003cb\u003eALL\u003c/b\u003e work in a biosafety cabinet (BSC).'\n      note '\u003cb\u003ePPE is required\u003c/b\u003e'\n      check 'Put on lab coat.'\n      check 'Put on 2 layers of gloves.'\n      bullet 'Make sure to use tight gloves. Tight gloves reduce the chance of the gloves getting caught on the tubes when closing their lids.'\n      bullet 'Change outer layer of gloves after handling infectious sample and before touching surfaces outside of the BSC (such as a refrigerator door handle).'\n    end\n  end\n\n  # TODO: Think about how to switch this to row-wise addition.\n  # Adds samples to to collections, provides instructions to tech\n  #\n  # @param operation_inputs [Array\u003citems\u003e]\n  # @param collection [Collection]\n  # @param layout_generator [LayoutGenerator]\n  # @param volume [{aty: int, unit: string}]\n  # @param column [int]\n  def add_samples(operation_inputs:, microtiter_plate:,\n                  volume:, column: nil)\n    operation_inputs.each do |fv|\n      item = fv.item\n      layout_group = microtiter_plate.associate_next_empty_group(\n        key: TEMPLATE_KEY,\n        data: { item: item.id, volume: volume },\n        column: column\n      )\n\n      association_map = []\n      layout_group.each { |r, c| association_map.push({ to_loc: [r, c] }) }\n      single_channel_item_to_collection(to_collection: microtiter_plate.collection,\n                                        source: item,\n                                        volume: volume,\n                                        association_map: association_map)\n    end\n  end\n\nend\n"}},{"library":{"name":"PrepareRTqPCRValidation","category":"Diagnostic RT-qPCR","code_source":"# frozen_string_literal: true\n\nmodule PrepareRTqPCRValidation\n\n  # Validates that all operations are as expected\n  #\n  # @param operations [OperationList] list of operations\n  # @raise rescue will Error any operations that do not pass validation\n  def validate(operation:, job_params:)\n    valid_op = true\n\n    valid_input, input_error = validate_inputs(operation, job_params)\n    valid_contents, content_error = validate_contents(operation, job_params)\n    unless valid_input\n      valid_op = false\n      operation.error(:IncompatibleInputsError, input_error)\n      display_error([{ op: operation, error: content_error }])\n    end\n\n    unless valid_contents\n      valid_op = false\n      operation.error(:InvalidContentsError, content_error)\n      display_error([{ op: operation, error: content_error }])\n    end\n\n    valid_op\n  end\n\n  def display_error(error_list)\n    error_type = error_list.first[:error]\n    tab = [['\u003cb\u003eOperation\u003cb\u003e', '\u003cb\u003eError Message\u003c/b\u003e']]\n    error_list.each do |err|\n      tab.push([err[:op].id, err[:error]])\n    end\n\n    show do\n      title 'Operation Error'\n      note \"The following operations had #{error_type}\"\n      table tab\n    end\n  end\n\n  def validate_contents(op, job_params)\n    [true, nil]\n  end\n\n  def validate_inputs(op, job_params)\n    [true, nil]\n  end\n\n  class IncompatibleInputsError \u003c ProtocolError; end\n  class InvalidContentsError \u003c ProtocolError; end\n\nend\n"}},{"library":{"name":"PrepareqPCRPlateHelper","category":"Diagnostic RT-qPCR","code_source":"# frozen_string_literal: true\n\nneeds 'PCR Libs/PCRCompositionDefinitions'\nneeds 'Collection Management/CollectionTransfer'\nneeds 'Standard Libs/WorkSpace'\nneeds 'Diagnostic RT-qPCR/DataAssociationKeys'\n\n# Protocol methods for setting up plate withe extracted RNA Samples\n#\n# @author Devin Strickland \u003cstrklnd@uw.edu\u003e\n# @author Cannon Mallory \u003cmalloc3@uw.edu\u003e\nmodule PrepareqPCRPlateHelper\n\n  include PCRCompositionDefinitions\n  include CollectionTransfer\n  include DataAssociationKeys\n\n  attr_reader :template\n\n  OPTIONS = 'options'\n  INPUT_PLATE = 'PCR Plate'\n  OUTPUT_PLATE = 'PCR Plate'\n  ASSAY_TYPE = 'Assay Type'\n\n  def add_inputs(collection:, samples:, volume:, station:)\n    return if samples.empty?\n\n    move_to_station(station)\n    layout_materials(samples + [collection])\n\n    samples.each do |item|\n      association_map = to_association_map(collection: collection,\n                                           item: item.sample)\n      single_channel_item_to_collection(to_collection: collection,\n                                        source: item.id,\n                                        volume: volume,\n                                        association_map: association_map)\n    end\n  end\n\n  def update_parameters(operation:,\n                        default_operation_params:,\n                        default_job_params:)\n\n    determine_default_job_params(operation: operation,\n                                 default_job_params: default_job_params)\n    opts = operation.plan.associations[:Options]\n    default_job_params.update(update_plan_params(plan_params: default_operation_params,\n                                                 opts: opts))\n  end\n\n  def determine_default_job_params(operation:, default_job_params:)\n    input_plate = operation.input(INPUT_PLATE).collection\n    default_job_params[:template] = get_composition_def(\n      name: input_plate.get(COMPOSITION_NAME_KEY))[:template]\n    @template = default_job_params[:template][:input_name]\n    group_size = input_plate.get('group_size'.to_sym).to_i\n    rows, columns = input_plate.dimensions\n    default_job_params[:group_size] = group_size\n    default_job_params[:max_inputs] = rows / group_size * columns\n  end\n\n  def setup_input_output_collections(input_collection:)\n    output_collection = exact_copy(input_collection, label_plates: false)\n    association_map = one_to_one_association_map(to_collection: output_collection,\n                                                 from_collection: input_collection)\n\n    associate_transfer_collection_to_collection(to_collection: output_collection,\n                                                from_collection: input_collection,\n                                                association_map: association_map)\n\n    relabel_plate(from_collection: input_collection,\n                  to_collection: output_collection)\n    output_collection\n  end\n\n  def sort_inputs(negative_control:, positive_control:, operation_inputs:)\n    remaining_inputs = []\n    negative_controls = []\n    positive_controls = []\n    operation_inputs.each do |input|\n      input_name = input.sample.name\n\n      if input_name.include?(negative_control)\n        negative_controls.push(input)\n      elsif input_name.include?(positive_control)\n        positive_controls.push(input)\n      else\n        remaining_inputs.push(input)\n      end\n    end\n    {negative_control: negative_controls,\n     positive_control: positive_controls,\n     standard_sample: remaining_inputs}\n  end\n\n  def setup_samples(operation_inputs:,\n                    collection:,\n                    layout_generator:,\n                    names_to_avoid: [],\n                    column: nil)\n    operation_inputs.each do |fv|\n      job_params[:max_inputs].times do\n        retry_group = true\n\n        layout_group = layout_generator.next_group(column: column)\n\n        layout_group.each do |r, c|\n          existing_part = collection.part(r, c)\n          raise \"Part #{r} , #{c}, #{layout_group}\" if existing_part.nil?\n\n          break if avoid_name(existing_part.sample.name, names_to_avoid)\n\n          collection.set(r, c, fv.sample)\n          from_obj_to_obj_provenance(collection.part(r, c), existing_part)\n          retry_group = false\n        end\n\n        column = layout_generator.iterate_column(column)\n        break unless retry_group\n      end\n    end\n  end\n\n  def avoid_name(name, names_to_avoid)\n    names_to_avoid.each do |avoid_name|\n      return true if name.include?(avoid_name)\n    end\n    false\n  end\n\n  def move_to_station(station)\n    show do\n      title 'Move to Proper Area'\n      note \"Please move to the \u003cb\u003e#{station}\u003c/b\u003e to complete the following steps\"\n    end\n  end\n\nend\n"}},{"library":{"name":"RNAExtractionHelper","category":"Diagnostic RT-qPCR","code_source":"# typed: false\n# frozen_string_literal: true\n\nneeds 'Standard Libs/PlanParams'\nneeds 'Standard Libs/Units'\nneeds 'Standard Libs/Debug'\nneeds 'RNA Extraction Kits/RNAExtractionKits'\n\n# Module for elements that are common to RNA Extraction Protocols\n#\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nmodule RNAExtractionHelper\n  include PlanParams\n  include Units\n  include Debug\n  include RNAExtractionKits\n  \n  def sample_volume(operation)\n    operation.temporary[:options][:sample_volume]\n  end\n\nend\n"}}]}